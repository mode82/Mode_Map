<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAPMODE - Index</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 40% -10%, #0d1731 0%, #070b12 55%, #05070c 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", "Segoe UI", Roboto, Arial, sans-serif;
      overflow:hidden;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 340px 1fr;
      grid-template-rows: 56px 1fr;
      gap:0;
    }

    /* Top bar */
    .topbar{
      grid-column: 1 / -1;
      height:56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(14,22,38,.92), rgba(11,18,32,.65));
      border-bottom:1px solid rgba(39,52,74,.55);
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 320px;
    }
    .logo{
      font-weight:900;
      letter-spacing:.5px;
      font-size: 18px;
      user-select:none;
    }
    .gameSelect{
      display:flex;
      align-items:center;
      gap:8px;
      background: rgba(14,22,38,.6);
      border: 1px solid rgba(39,52,74,.7);
      border-radius: 12px;
      padding: 6px 10px;
    }
    select{
      background: transparent;
      color: var(--text);
      border: none;
      outline: none;
      font-size: 14px;
      appearance: none;
      padding-right: 14px;
      cursor: default;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .btn{
      height:30px;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.55);
      color: var(--text);
      font-size: 13px;
      cursor: default;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(124,196,255,.55); }
    .btn.primary{
      border-color: rgba(124,196,255,.8);
      box-shadow: 0 0 0 2px rgba(124,196,255,.12) inset;
    }

    /* Left panel */
    .sidebar{
      grid-row: 2 / -1;
      padding: 14px;
      background: linear-gradient(180deg, rgba(11,18,32,.70), rgba(8,12,20,.55));
      border-right:1px solid rgba(39,52,74,.55);
      backdrop-filter: blur(10px);
      overflow:auto;
    }
    .sectionTitle{
      font-size: 13px;
      color: var(--muted);
      letter-spacing:.2px;
      margin: 4px 0 10px;
    }
    .pageList{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .pageBtn{
      width:100%;
      height:44px;
      border-radius: 12px;
      border: 1px solid rgba(39,52,74,.75);
      background: rgba(14,22,38,.40);
      color: var(--text);
      font-size: 14px;            /* ✅ 어드민 느낌의 기본 폰트 크기 */
      font-weight: 700;
      display:flex;
      align-items:center;
      padding: 0 12px;
      cursor: default;
      user-select:none;
      box-shadow: var(--shadow2);
    }
    .pageBtn.active{
      border-color: rgba(57,217,138,.75);
      box-shadow: 0 0 0 2px rgba(57,217,138,.12) inset;
    }
    .hint{
      margin-top: 12px;
      color: rgba(159,176,198,.95);
      font-size: 12px;
      line-height: 1.4;
    }

    /* Canvas area */
    .main{
      grid-row: 2 / -1;
      position:relative;
      overflow:hidden;
      background: rgba(0,0,0,.15);
    }
    .canvasWrap{
      position:absolute;
      inset: 10px 10px 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(39,52,74,.55);
      background: rgba(6,10,18,.35);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    /* ✅ 모바일 핀치 줌/패닝을 위해 필수 (브라우저 기본 제스처 차단) */
    canvas{
      display:block;
      width:100%;
      height:100%;
      cursor: default;            /* ✅ 손모양(포인터) 금지 */
      touch-action: none;         /* ✅ 2손가락 확대/축소 직접 구현 */
    }

    .toast{
      position:absolute;
      left:50%;
      bottom:16px;
      transform: translateX(-50%);
      padding: 8px 12px;
      background: rgba(14,22,38,.72);
      border:1px solid rgba(39,52,74,.7);
      border-radius: 12px;
      font-size: 12px;
      color: rgba(231,238,248,.92);
      box-shadow: var(--shadow2);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      white-space:nowrap;
    }
    .toast.show{ opacity:1; }

    /* Mobile */
    @media (max-width: 980px){
      .app{
        grid-template-columns: 300px 1fr;
      }
    }
    @media (max-width: 780px){
      .app{
        grid-template-columns: 1fr;
        grid-template-rows: 56px 170px 1fr;
      }
      .sidebar{
        grid-column: 1 / -1;
        grid-row: 2 / 3;
        border-right:none;
        border-bottom:1px solid rgba(39,52,74,.55);
      }
      .main{
        grid-column: 1 / -1;
        grid-row: 3 / -1;
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <div class="logo">MAPMODE</div>
        <div class="gameSelect" title="게임 선택">
          <select id="gameSelect"></select>
        </div>
      </div>
      <div class="actions">
        <button class="btn" id="btnZoomOut">-</button>
        <button class="btn" id="btnZoomIn">+</button>
        <button class="btn primary" id="btnReset">전체 초기화</button>
      </div>
    </div>

    <aside class="sidebar">
      <div class="sectionTitle">페이지</div>
      <div class="pageList" id="pageList"></div>
      <div class="hint">
        • 좌클릭 드래그로 지도 이동<br/>
        • 마우스 휠로 확대/축소<br/>
        • 모바일: 두 손가락 핀치로 확대/축소, 한 손가락 드래그로 이동
      </div>
    </aside>

    <main class="main">
      <div class="canvasWrap">
        <canvas id="mapCanvas"></canvas>
      </div>
      <div class="toast" id="toast"></div>
    </main>
  </div>

  <script>
  (() => {
    "use strict";

    // ✅ GitHub Pages 기준 상태 파일 경로 통일 (요청하신 규칙)
    const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

    const $ = (s) => document.querySelector(s);
    const canvas = $("#mapCanvas");
    const ctx = canvas.getContext("2d", { alpha: true });

    const gameSelect = $("#gameSelect");
    const pageListEl = $("#pageList");
    const toastEl = $("#toast");
    const btnReset = $("#btnReset");
    const btnZoomIn = $("#btnZoomIn");
    const btnZoomOut = $("#btnZoomOut");

    // ---------- Toast ----------
    let toastTimer = null;
    function toast(msg, ms=1200){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> toastEl.classList.remove("show"), ms);
    }

    // ---------- State (여러 스키마 호환) ----------
    function normalizeState(raw){
      // 기대: games -> pages -> markers
      // 혹시 pages 바로 있거나 currentPage만 있는 경우도 최대한 흡수
      const out = { games: [], ui: {} };

      if (!raw || typeof raw !== "object") return out;

      // games 형태
      if (Array.isArray(raw.games)) {
        out.games = raw.games.map(g => ({
          name: g.name ?? g.title ?? "게임",
          pages: normalizePages(g.pages ?? g.maps ?? [])
        }));
      }
      // top-level pages 형태
      else if (Array.isArray(raw.pages) || Array.isArray(raw.maps)) {
        out.games = [{
          name: raw.gameName ?? raw.title ?? "게임",
          pages: normalizePages(raw.pages ?? raw.maps ?? [])
        }];
      }
      // 완전 최소 형태
      else {
        out.games = [{
          name: raw.gameName ?? "게임",
          pages: normalizePages(raw.pages ?? [])
        }];
      }

      out.ui = raw.ui ?? {};
      return out;

      function normalizePages(pages){
        const arr = Array.isArray(pages) ? pages : [];
        return arr.map(p => {
          const imgUrl =
            p.imageUrl ??
            p.image?.url ??
            p.mapImageUrl ??
            p.map?.url ??
            p.url ??
            null;

          return {
            title: p.title ?? p.name ?? p.pageName ?? "페이지",
            imageUrl: imgUrl,
            markers: normalizeMarkers(p.markers ?? p.points ?? p.nodes ?? []),
          };
        });
      }

      function normalizeMarkers(markers){
        const arr = Array.isArray(markers) ? markers : [];
        return arr.map((m, idx) => {
          const n =
            m.n ?? m.no ?? m.num ?? m.number ?? m.seq ?? (idx + 1);

          return {
            id: m.id ?? `${idx}`,
            x: Number(m.x ?? m.px ?? m.left ?? 0),
            y: Number(m.y ?? m.py ?? m.top ?? 0),
            label: String(m.label ?? m.text ?? m.name ?? ""),
            number: Number(n) || 0,
            color: m.color ?? m.fill ?? "auto",
            group: m.group ?? m.type ?? "",
            dim: !!m.dim, // 클릭 불투명(30%) 토글
          };
        });
      }
    }

    async function loadState(){
      // 1) 최신 state.json
      try{
        const r = await fetch(REMOTE_STATE_URL.toString(), { cache: "no-store" });
        if (!r.ok) throw new Error("state.json fetch failed");
        const raw = await r.json();
        return normalizeState(raw);
      }catch(e){
        // 2) 임시 fallback: 최소 데모(깨진 화면 방지)
        return normalizeState({
          games:[{name:"아이온2", pages:[{title:"전체지도", imageUrl:null, markers:[] }]}]
        });
      }
    }

    // ---------- Viewport / Transform ----------
    const view = {
      // world: 이미지 좌표계(픽셀)
      tx: 0, ty: 0,  // screen translate
      scale: 1,
      minScale: 0.08,
      maxScale: 12,
    };

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function screenToWorld(sx, sy){
      const x = (sx - view.tx) / view.scale;
      const y = (sy - view.ty) / view.scale;
      return { x, y };
    }
    function worldToScreen(wx, wy){
      const x = wx * view.scale + view.tx;
      const y = wy * view.scale + view.ty;
      return { x, y };
    }

    function zoomAt(factor, sx, sy){
      const before = screenToWorld(sx, sy);
      const ns = clamp(view.scale * factor, view.minScale, view.maxScale);
      const realFactor = ns / view.scale;
      view.scale = ns;
      // keep point under cursor
      view.tx = sx - before.x * view.scale;
      view.ty = sy - before.y * view.scale;
      return realFactor;
    }

    // ---------- Canvas resize (✅ 해상도 유지: DPR 적용) ----------
    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      canvas.width  = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      render();
    }
    window.addEventListener("resize", resizeCanvas);

    // ---------- Data / Selection ----------
    let STATE = null;
    let currentGameIndex = 0;
    let currentPageIndex = 0;

    let mapImg = new Image();
    mapImg.decoding = "async";
    mapImg.crossOrigin = "anonymous";
    let mapReady = false;

    function setPage(gameIdx, pageIdx){
      currentGameIndex = gameIdx;
      currentPageIndex = pageIdx;

      // UI
      [...pageListEl.querySelectorAll(".pageBtn")].forEach((b, i) => {
        b.classList.toggle("active", i === pageIdx);
      });

      // load image
      const page = getCurrentPage();
      mapReady = false;
      if (!page || !page.imageUrl){
        mapReady = false;
        toast("지도 이미지가 없습니다. (state.json의 imageUrl 확인)");
        render();
        return;
      }

      mapImg = new Image();
      mapImg.decoding = "async";
      mapImg.crossOrigin = "anonymous";
      mapImg.onload = () => {
        mapReady = true;
        fitToScreen();     // 페이지 전환 시 화면 맞춤
        render();
      };
      mapImg.onerror = () => {
        mapReady = false;
        toast("지도 이미지 로드 실패 (경로/대소문자/캐시 확인)");
        render();
      };
      mapImg.src = page.imageUrl;
    }

    function getCurrentGame(){
      return STATE?.games?.[currentGameIndex] ?? null;
    }
    function getCurrentPage(){
      const g = getCurrentGame();
      return g?.pages?.[currentPageIndex] ?? null;
    }

    // ✅ 전체 맞춤 (처음/리셋 시)
    function fitToScreen(){
      if (!mapReady) return;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      const pad = 28;
      const sx = (w - pad*2) / mapImg.width;
      const sy = (h - pad*2) / mapImg.height;
      view.scale = clamp(Math.min(sx, sy), view.minScale, view.maxScale);

      // center
      const cx = w * 0.5;
      const cy = h * 0.5;
      view.tx = cx - (mapImg.width * 0.5) * view.scale;
      view.ty = cy - (mapImg.height * 0.5) * view.scale;
    }

    // ---------- Marker drawing (✅ 숫자/폰트/선 복구) ----------
    function autoColorFor(m){
      // 관리자 페이지 느낌: 그룹/타입이 있으면 색을 나눔(없으면 빨강/파랑/노랑 순환)
      if (m.color && m.color !== "auto") return m.color;
      const n = Math.abs(Number(m.number) || 0);
      const mod = n % 3;
      if (mod === 1) return "#ff5d5d";  // red
      if (mod === 2) return "#7cc4ff";  // blue
      return "#ffd60a";                 // yellow
    }

    function drawLinePath(markers){
      // ✅ 선이 사라진 문제: 숫자 순(또는 배열 순)으로 연결
      // number가 유효하면 number 기준 정렬
      const list = markers.slice();
      const hasNumber = list.some(m => Number.isFinite(m.number));
      if (hasNumber) list.sort((a,b) => (a.number||0) - (b.number||0));

      ctx.save();
      ctx.lineWidth = 2 / Math.max(0.9, view.scale); // 확대 시 굵기 과도 증가 방지
      ctx.strokeStyle = "rgba(255,255,255,.90)";
      ctx.shadowColor = "rgba(0,0,0,.35)";
      ctx.shadowBlur = 6 / Math.max(1, view.scale);
      ctx.beginPath();

      let started = false;
      for (const m of list){
        if (!isFinite(m.x) || !isFinite(m.y)) continue;
        const x = m.x, y = m.y;
        if (!started){
          ctx.moveTo(x, y);
          started = true;
        }else{
          ctx.lineTo(x, y);
        }
      }
      if (started) ctx.stroke();
      ctx.restore();

      // 화살표는 간단히 마지막 방향에만 표시(필요 시 확장 가능)
      if (list.length >= 2){
        for (let i=1;i<list.length;i++){
          const a = list[i-1], b = list[i];
          drawArrow(a.x, a.y, b.x, b.y);
        }
      }
    }

    function drawArrow(x1,y1,x2,y2){
      const dx = x2-x1, dy = y2-y1;
      const len = Math.hypot(dx,dy);
      if (len < 1e-6) return;
      const ux = dx/len, uy = dy/len;

      const head = 10 / Math.max(0.9, view.scale);
      const back = 16 / Math.max(0.9, view.scale);

      const px = x2 - ux*back;
      const py = y2 - uy*back;

      const nx = -uy, ny = ux;

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.shadowColor = "rgba(0,0,0,.35)";
      ctx.shadowBlur = 6 / Math.max(1, view.scale);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(px + nx*head, py + ny*head);
      ctx.lineTo(px - nx*head, py - ny*head);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawMarker(m){
      const r = 14; // 월드 기준 반지름(줌에 따라 자연스럽게 커짐)
      const fill = autoColorFor(m);

      const isDim = !!m.dim;
      const alpha = isDim ? 0.30 : 1.0;

      // circle
      ctx.save();
      ctx.globalAlpha = alpha;

      ctx.beginPath();
      ctx.arc(m.x, m.y, r, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(0,0,0,.85)";
      ctx.stroke();

      // number (✅ 사라진 숫자 복구)
      const num = (m.number ?? 0);
      ctx.fillStyle = "#06101d";
      ctx.font = "900 14px ui-sans-serif, system-ui, -apple-system, 'Apple SD Gothic Neo', 'Noto Sans KR'";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(num), m.x, m.y+0.5);
      ctx.restore();

      // label text (어드민 기준 느낌: 굵고 선명)
      if (m.label){
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = "800 18px ui-sans-serif, system-ui, -apple-system, 'Apple SD Gothic Neo', 'Noto Sans KR'";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,255,255,.95)";
        // outline for readability
        ctx.lineWidth = 5;
        ctx.strokeStyle = "rgba(0,0,0,.45)";
        ctx.strokeText(m.label, m.x + r + 10, m.y);
        ctx.fillText(m.label, m.x + r + 10, m.y);
        ctx.restore();
      }
    }

    function hitTestMarker(worldX, worldY){
      const page = getCurrentPage();
      if (!page) return null;
      const markers = page.markers || [];
      // 반지름 14(world) 기준
      for (let i=markers.length-1; i>=0; i--){
        const m = markers[i];
        const dx = worldX - m.x;
        const dy = worldY - m.y;
        if (Math.hypot(dx,dy) <= 16) return m;
      }
      return null;
    }

    // ---------- Render ----------
    function clear(){
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);
    }

    function render(){
      clear();
      const rect = canvas.getBoundingClientRect();

      // background
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.08)";
      ctx.fillRect(0,0,rect.width,rect.height);
      ctx.restore();

      if (!mapReady){
        // placeholder
        ctx.save();
        ctx.fillStyle = "rgba(231,238,248,.75)";
        ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, 'Apple SD Gothic Neo', 'Noto Sans KR'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("지도 로딩 중... (또는 imageUrl 없음)", rect.width/2, rect.height/2);
        ctx.restore();
        return;
      }

      // world transform
      ctx.save();
      ctx.translate(view.tx, view.ty);
      ctx.scale(view.scale, view.scale);

      // image
      ctx.drawImage(mapImg, 0, 0);

      const page = getCurrentPage();
      const markers = (page?.markers || []);

      // ✅ 선 먼저 그리고 -> 마커 (선이 가려지지 않게)
      if (markers.length >= 2){
        drawLinePath(markers);
      }

      // markers
      for (const m of markers){
        if (!isFinite(m.x) || !isFinite(m.y)) continue;
        drawMarker(m);
      }

      ctx.restore();
    }

    // ---------- Input (✅ 좌클릭 드래그 패닝 / ✅ 모바일 핀치 줌 복구 / ✅ 커서 원복) ----------
    let isPanning = false;
    let lastSX = 0, lastSY = 0;

    // pointer tracking for pinch
    const pointers = new Map(); // id -> {x,y}
    let pinchStartDist = 0;
    let pinchStartScale = 1;
    let pinchStartMid = {x:0,y:0};

    function setCursor(mode){
      // ✅ "손모양" 방지: pointer 커서 사용 금지
      if (mode === "dragging") canvas.style.cursor = "grabbing";
      else canvas.style.cursor = "default";
    }

    canvas.addEventListener("pointerdown", (e) => {
      // ✅ 텍스트 선택/드래그 등 기본 동작 방지
      e.preventDefault();

      canvas.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      // 2 finger pinch start
      if (pointers.size === 2){
        const pts = [...pointers.values()];
        pinchStartDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        pinchStartScale = view.scale;
        pinchStartMid = { x: (pts[0].x + pts[1].x)/2 - rect.left, y: (pts[0].y + pts[1].y)/2 - rect.top };
        isPanning = false;
        setCursor("default");
        return;
      }

      // single pointer
      lastSX = sx; lastSY = sy;

      // ✅ 마커 클릭이면 불투명 토글(기존 요구사항 포함)
      const w = screenToWorld(sx, sy);
      const m = hitTestMarker(w.x, w.y);
      if (m){
        // 클릭: 해당 마커만 토글
        m.dim = !m.dim;
        render();
        return;
      }

      // ✅ 좌클릭/터치 드래그로 패닝 시작
      isPanning = true;
      setCursor("dragging");
    }, { passive: false });

    canvas.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      // pinch zoom
      if (pointers.size === 2){
        const pts = [...pointers.values()];
        const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        const mid = { x: (pts[0].x + pts[1].x)/2 - rect.left, y: (pts[0].y + pts[1].y)/2 - rect.top };
        if (pinchStartDist > 0){
          const factor = dist / pinchStartDist;
          // scale around midpoint
          const targetScale = clamp(pinchStartScale * factor, view.minScale, view.maxScale);
          const realFactor = targetScale / view.scale;
          zoomAt(realFactor, mid.x, mid.y);
          render();
        }
        return;
      }

      // single pointer pan
      if (!isPanning) return;

      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const dx = sx - lastSX;
      const dy = sy - lastSY;

      view.tx += dx;
      view.ty += dy;

      lastSX = sx; lastSY = sy;
      render();
    }, { passive: false });

    function endPointer(e){
      if (!pointers.has(e.pointerId)) return;
      e.preventDefault();
      pointers.delete(e.pointerId);

      if (pointers.size < 2){
        pinchStartDist = 0;
      }
      if (pointers.size === 0){
        isPanning = false;
        setCursor("default");
      }
    }
    canvas.addEventListener("pointerup", endPointer, { passive:false });
    canvas.addEventListener("pointercancel", endPointer, { passive:false });

    // wheel zoom (desktop)
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      const delta = Math.sign(e.deltaY);
      const factor = delta > 0 ? 0.90 : 1.11;
      zoomAt(factor, sx, sy);
      render();
    }, { passive:false });

    // Buttons
    btnReset.addEventListener("click", () => {
      // dim 초기화 + 화면 맞춤
      const page = getCurrentPage();
      if (page?.markers) page.markers.forEach(m => m.dim = false);
      fitToScreen();
      render();
      toast("초기화 완료");
    });

    btnZoomIn.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(1.15, rect.width/2, rect.height/2);
      render();
    });
    btnZoomOut.addEventListener("click", () => {
      const rect = canvas.getBoundingClientRect();
      zoomAt(0.87, rect.width/2, rect.height/2);
      render();
    });

    // ---------- UI build ----------
    function buildUI(){
      // games
      gameSelect.innerHTML = "";
      STATE.games.forEach((g, i) => {
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = g.name ?? `게임 ${i+1}`;
        gameSelect.appendChild(opt);
      });
      gameSelect.value = String(currentGameIndex);

      gameSelect.addEventListener("change", () => {
        currentGameIndex = Number(gameSelect.value) || 0;
        currentPageIndex = 0;
        buildPageList();
        setPage(currentGameIndex, currentPageIndex);
      });

      buildPageList();
    }

    function buildPageList(){
      pageListEl.innerHTML = "";
      const g = getCurrentGame();
      const pages = g?.pages ?? [];
      pages.forEach((p, i) => {
        const b = document.createElement("button");
        b.className = "pageBtn";
        b.textContent = p.title ?? `페이지 ${i+1}`;
        b.addEventListener("click", () => {
          currentPageIndex = i;
          setPage(currentGameIndex, currentPageIndex);
        });
        pageListEl.appendChild(b);
      });
    }

    // ---------- Boot ----------
    (async () => {
      STATE = await loadState();
      // 기본 선택 보정
      if (!STATE.games.length) {
        STATE.games = [{ name:"게임", pages:[{ title:"전체지도", imageUrl:null, markers:[] }] }];
      }
      currentGameIndex = clamp(currentGameIndex, 0, STATE.games.length-1);
      currentPageIndex = 0;

      buildUI();
      resizeCanvas(); // 먼저 크기 잡고
      setPage(currentGameIndex, currentPageIndex); // 이미지 로드 + fit
    })();

  })();
  </script>
</body>
</html>
