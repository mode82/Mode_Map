<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Multi-Map Demo v7.0.0</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      --topSlotW: 150px;
      --topSlotH: 38px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }

    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.9);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    button, input, select, textarea{
      background: rgba(16,24,38,.65);
      border: 1px solid rgba(39,52,74,.9);
      color: var(--text);
      border-radius: var(--r14);
      padding:9px 11px;
      font-size:14px;
      outline:none;
      transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }

    button{ cursor:pointer; font-weight:800; }
    button:hover{ border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 3px rgba(124,196,255,.12); }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; box-shadow:none; }
    input:focus, select:focus, textarea:focus, button:focus-visible{
      border-color: rgba(124,196,255,.8);
      box-shadow: 0 0 0 4px rgba(124,196,255,.14);
    }

    .ghost{ background: rgba(9,14,24,.55); }
    .ok{ border-color: rgba(57,217,138,.65) !important; background: rgba(10,22,16,.55) !important; }
    .danger{ border-color: rgba(255,93,93,.55) !important; background: rgba(26,10,12,.55) !important; }
    .warn{ border-color: rgba(255,214,10,.55) !important; background: rgba(22,18,10,.55) !important; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(39,52,74,.9);
      border-radius:999px;
      background: rgba(14,22,38,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.6);
    }

    .badge.ok{ border-color: rgba(57,217,138,.6); background: rgba(10,22,16,.55); }

    .muted{ color: var(--muted); font-size:12px; }
    .k{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr 380px;
      height: calc(100vh - 56px);
    }

    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
    }

    .panel.left{ border-right:1px solid rgba(31,42,58,.85); }
    .panel.right{ border-left:1px solid rgba(31,42,58,.85); }

    .center{ position:relative; overflow:hidden; }
    #canvas{
      width:100%;
      height:100%;
      display:block;
      background:#0b0f14;
      /* ✅ 드래그 기본 동작 방지(텍스트 선택/이미지 드래그 등) */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      cursor: grab;
    }
    #canvas:active{ cursor: grabbing; }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }

    .section h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color: rgba(231,238,248,.92);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .row{ display:flex; gap:8px; margin:8px 0; }
    .row > *{ flex:1; }

    .hr{ height:1px; background: rgba(31,42,58,.9); margin:12px 0; }

    .catGrid{ display:flex; flex-wrap:wrap; gap:8px; }
    .catBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .catDot{
      width:10px;
      height:10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-block;
    }

    .catBtn.active{
      border-color: rgba(124,196,255,.9);
      box-shadow: 0 0 0 3px rgba(124,196,255,.14);
    }

    .palette{ display:flex; flex-wrap:wrap; gap:10px; }
    .swatchWrap{ display:flex; flex-direction:column; align-items:center; gap:4px; }
    .swatch{
      width:36px; height:36px;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(8,12,20,.55);
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }
    .swatch button{
      width:28px; height:28px;
      border-radius:10px;
      border:1px solid rgba(39,52,74,.9);
      padding:0;
      background:transparent;
    }
    .swatch.active{ outline:2px solid rgba(124,196,255,.9); outline-offset:2px; }
    .swatchLabel{ font-size:11px; color: var(--muted); }

    .smallBtn{ padding:9px 11px; font-size:13px; }

    .linkBox{
      padding:12px 12px;
      border:1px solid rgba(39,52,74,.9);
      border-radius: var(--r16);
      background: rgba(8,12,20,.55);
      word-break:break-all;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    #hoverOverlay{
      position:absolute;
      display:none;
      z-index:50;
      background: rgba(10,16,28,.78);
      border: 1px solid rgba(124,196,255,.18);
      border-radius: var(--r16);
      padding:10px 12px;
      max-width:min(420px, 84vw);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      pointer-events:auto;
    }

    #hoverOverlay .memoLabel{
      font-size:12px;
      color: var(--muted);
      margin-bottom:6px;
      font-weight:800;
      letter-spacing:.2px;
    }

    #hoverOverlay textarea{
      width: 100%;
      resize:none;
      line-height:1.35;
      padding:10px 10px;
      border-radius:12px;
      margin-bottom:10px;
      font-size:13px;
    }

    #hoverOverlay textarea[readonly]{ opacity: .95; }
    #hoverOverlay .yt{ font-size:14px; font-weight:900; letter-spacing:.2px; }
    #hoverOverlay .yt a{ color: rgba(231,238,248,.95); text-decoration:none; }
    #hoverOverlay .yt a:hover{ text-decoration: underline; }

    .modalBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:999;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .modal{
      width:min(860px, 100%);
      border:1px solid rgba(39,52,74,.95);
      border-radius: var(--r18);
      background: linear-gradient(180deg, rgba(14,22,38,.92), rgba(10,16,28,.88));
      box-shadow: var(--shadow);
      overflow:hidden;
      max-height: min(86vh, 980px);
      display:flex;
      flex-direction:column;
    }

    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid rgba(31,42,58,.9);
      background: rgba(8,12,20,.35);
      flex:0 0 auto;
    }

    .modalHeader b{ font-size:14px; letter-spacing:.2px; }
    .modalBody{ padding:12px 14px; overflow:auto; flex: 1 1 auto; }
    .modalBody label{ display:block; font-size:12px; color: var(--muted); margin:10px 0 6px; }

    .modalFooter{
      display:flex;
      gap:8px;
      padding:12px 14px;
      border-top:1px solid rgba(31,42,58,.9);
      justify-content:flex-end;
      background: rgba(8,12,20,.25);
      flex:0 0 auto;
      flex-wrap:wrap;
      align-items:center;
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }

    @media (max-width: 1100px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .panel.left{ border-right:none; border-bottom:1px solid rgba(31,42,58,.85); }
      .panel.right{ border-left:none; border-top:1px solid rgba(31,42,58,.85); }
      #canvas{ height: 55vh; }
      .grid2{ grid-template-columns: 1fr; }
    }

    input[type="color"]{
      width:46px;
      height:38px;
      padding:0;
      border-radius:12px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(16,24,38,.65);
    }

    .quickColorRow{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .qc{
      width:30px; height:30px;
      border-radius:10px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
    }
    .qc > i{ width:20px; height:20px; border-radius:8px; display:block; border:1px solid rgba(39,52,74,.9); }

    .styleRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:stretch; }
    .styleCard{
      border:1px solid rgba(39,52,74,.8);
      background: rgba(8,12,20,.35);
      border-radius: var(--r16);
      padding:10px 12px;
      flex: 1 1 240px;
      min-width: 240px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .styleCard .head{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
    .styleCard .head .t{ font-weight:900; }
    .styleCard .head .d{ color: var(--muted); font-size:12px; }

    .rangeRow{ display:flex; align-items:center; gap:10px; }
    .rangeRow input[type="range"]{ flex:1; }
    .rangeRow input[type="number"]{ width:86px; }

    .resetDanger{
      border: 2px solid rgba(255,93,93,.92) !important;
      background: rgba(26,10,12,.45) !important;
      box-shadow: 0 0 0 4px rgba(255,93,93,.10);
    }

    .pageBtn{
      width:100%;
      padding:12px 12px;
      border-radius: var(--r16);
      border: 2px solid rgba(124,196,255,.40);
      background: rgba(10,18,30,.45);
      box-shadow: 0 0 0 4px rgba(124,196,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      text-align:left;
    }
    .pageBtn:hover{
      border-color: rgba(124,196,255,.75);
      box-shadow: 0 0 0 4px rgba(124,196,255,.12);
    }
    .pageBtn.active{
      border-color: rgba(57,217,138,.85);
      box-shadow: 0 0 0 4px rgba(57,217,138,.12);
    }
    .pageBtn .name{
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .pageBtn .meta{
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
      flex:0 0 auto;
    }

    .pageActions{ display:flex; gap:6px; flex:0 0 auto; }
    .iconBtn{
      padding:6px 8px;
      border-radius:12px;
      font-size:12px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.45);
    }
    .iconBtn:hover{ border-color: rgba(124,196,255,.55); box-shadow:none; }
    .iconBtn.danger{ border-color: rgba(255,93,93,.55) !important; }

    .titleWrap{ position:relative; }
    .titleBtn{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      letter-spacing:.2px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      cursor:pointer;
      user-select:none;
      width: 100%;
      justify-content: space-between;
    }
    .titleBtn:hover{ border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 3px rgba(124,196,255,.12); }
    .titleBtn .caret{ opacity:.8; }

    .drop{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      width: min(420px, 72vw);
      background: rgba(10,16,28,.90);
      border:1px solid rgba(39,52,74,.95);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      padding:10px;
      display:none;
      z-index:999;
    }
    .drop .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(8,12,20,.35);
      margin-bottom:8px;
    }
    .drop .item:last-child{ margin-bottom:0; }
    .drop .item .left{ min-width:0; }
    .drop .item .gname{ font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .drop .item .gmeta{ font-size:12px; color: var(--muted); margin-top:4px; }

    .topSlots{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .topSlot{
      width: var(--topSlotW);
      height: var(--topSlotH);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      overflow:hidden;
      position:relative;
      flex: 0 0 auto;
    }
    .topSlot.placeholder{
      opacity: 0;
      pointer-events: none;
    }

    #logoSlot{
      padding: 0;
      justify-content: center;
      border: 0;
    }
    #logoImg{
      width:100%;
      height:100%;
      object-fit: contain;
      display:none;
      padding:4px;
    }
    #logoUploadBtn{
      position:absolute;
      inset:0;
      border:0;
      background: transparent;
      cursor:pointer;
      font-weight:900;
      color: rgba(231,238,248,.88);
      display:none;
    }
  </style>
</head>

<body>
  <header>
    <div class="topSlots" id="topSlots">
      <div class="topSlot" id="logoSlot" title="로고 자리 (카테고리1)">
        <img id="logoImg" alt="logo" />
        <button id="logoUploadBtn" class="adminOnly" type="button">로고 URL</button>
      </div>

      <div class="topSlot" id="cat2Slot" title="카테고리2 (현재 게임)">
        <div class="titleWrap" id="titleWrap" style="width:100%; height:100%;">
          <div class="titleBtn" id="gameTitleBtn" title="클릭해서 게임 목록/추가" style="height:100%;">
            <span id="gameTitleText" style="min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">Map Demo</span>
            <span class="muted caret">▾</span>
          </div>
          <div class="drop" id="gameDrop"></div>
        </div>
      </div>

      <div class="topSlot placeholder" id="cat3Slot" aria-hidden="true"></div>
      <div class="topSlot placeholder" id="cat4Slot" aria-hidden="true"></div>
    </div>

    <span class="pill" id="adminToggleWrap">
      <span class="badge" id="modeBadge">USER</span>
      <label class="muted" style="margin:0;">관리자</label>
      <input id="adminToggle" type="checkbox" />
    </span>

    <button id="uploadBtn" class="adminOnly">지도 업로드</button>
    <button id="exportStateBtn" class="adminOnly">state.json 내보내기</button>
    <button id="resetViewBtn" class="adminOnly">뷰 리셋</button>
    <button id="clearAllBtn" class="danger adminOnly">전체 초기화</button>
    <input id="fileInput" type="file" accept="image/*" style="display:none;" />
  </header>

  <div class="wrap">
    <aside class="panel left">
      <div class="section">
        <h3>
          페이지
          <span class="badge" id="pageBadge" style="margin-left:auto;">-</span>
        </h3>

        <button id="addPageBtn" class="pageBtn adminOnly" style="justify-content:center;">
          <span class="name">+ 페이지 추가</span>
        </button>

        <div class="muted adminOnly" style="margin:10px 0 8px; line-height:1.4;">
          • 페이지 버튼 클릭 → 같은 게임 안에서 지도 페이지 이동<br/>
          • <b>폰/다른 기기</b>에서도 지도 보이게 하려면: 관리자에서 <b>URL</b> 버튼으로 지도 이미지 URL 설정
        </div>

        <div id="pageList" style="display:flex; flex-direction:column; gap:10px;"></div>
      </div>
    </aside>

    <div class="center" id="centerStage">
      <canvas id="canvas"></canvas>

      <div id="hoverOverlay">
        <div class="memoLabel">메모</div>
        <textarea id="hoverMemo" cols="10" rows="3" placeholder="" readonly></textarea>
        <div class="yt" id="hoverYt">-</div>
      </div>
    </div>

    <aside class="panel right">
      <div class="section" id="categorySection">
        <h3>카테고리</h3>
        <div class="catGrid" id="categoryBar"></div>
        <div class="muted" id="countInfo" style="margin-top:10px;">-</div>

        <div class="row adminOnly" id="adminCategoryTools" style="margin-top:10px;">
          <button id="editCategoriesBtn">카테고리/색상 편집</button>
        </div>
      </div>

      <div class="section adminOnly" id="adminToolsSection">
        <h3>관리자 툴</h3>
        <div class="muted" style="line-height:1.45;">
          • 색상 팔레트(체인 1번 기준 전파)<br/>
          • 선은 “같은 카테고리 필터” 시 같이 표시/숨김
        </div>

        <div class="hr"></div>

        <div class="muted">빠른 색상 (원 색상 오버라이드)</div>
        <div class="palette" id="paletteBar" style="margin-top:8px;"></div>

        <div class="row">
          <button id="applyPaletteToSelectedBtn" class="smallBtn" disabled>선택 마커에 적용</button>
          <button id="clearOverrideBtn" class="smallBtn ghost" disabled>선택 마커 색상(카테고리로)</button>
        </div>

        <div class="hr"></div>

        <div class="row">
          <button id="removeAllLinksBtn" class="smallBtn danger">모든 선 제거</button>
          <button id="resetChainBtn" class="smallBtn ghost">선 다시 체인(전체)</button>
        </div>

        <div class="hr"></div>

        <div class="muted" style="line-height:1.45;">
          • 현재 우클릭 기본 카테고리: <span class="k" id="createCategoryHint">-</span>
        </div>
        <div class="muted" style="line-height:1.45; margin-top:6px;">
          • 현재 "이어붙이기 기준": <span class="k" id="insertAfterHint">없음</span>
        </div>
      </div>

      <div class="section" id="userResetSection">
        <button id="resetDimBtn" class="smallBtn resetDanger" style="width:100%;">마커 초기화</button>
      </div>

      <div class="section" id="selectedSection">
        <h3 id="selectedHeader">선택한 마커</h3>
        <div class="hr"></div>
        <div class="muted">링크</div>
        <div id="youtubeBox" class="linkBox" style="margin-top:8px;">-</div>
      </div>
    </aside>
  </div>

  <!-- (모달들: index에선 사용 안하지만 구조 유지) -->
  <div class="modalBackdrop" id="markerModalBackdrop" aria-hidden="true"></div>
  <div class="modalBackdrop" id="catModalBackdrop" aria-hidden="true"></div>

  <script>
    if (typeof structuredClone !== "function") {
      window.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));
    }
  </script>

  <script>
    (() => {
      // ==========================================================
      // page detect
      // ==========================================================
      const IS_ADMIN_PAGE = /admin82\.html$/i.test(location.pathname);
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      const IS_COARSE_POINTER = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
      const SCALE_MARKERS_WITH_ZOOM = IS_COARSE_POINTER;

      const DEFAULT_MAP_IMAGE_URL = new URL("./assets/maps/aion2map.jpg", location.href).toString();
      const DEFAULT_LOGO_URL = new URL("./assets/logo/MAPMODELOGO2.png", location.href).toString();

      const REMOTE_STATE_URL = new URL("./data/state.json", location.href).toString();
      const REMOTE_SYNC_INTERVAL_MS = 15000;

      // ==========================================================
      // logo
      // ==========================================================
      const LOGO_KEY = "mm_logo_url_v1";
      const $logoImg = document.getElementById("logoImg");
      const $logoUploadBtn = document.getElementById("logoUploadBtn");
      const $logoSlot = document.getElementById("logoSlot");

      function normalizeUrlMaybe(u){
        const v = String(u || "").trim();
        if(!v) return "";
        try { return new URL(v, location.href).toString(); } catch { return v; }
      }
      function loadLogo(){
        try{
          let raw = (localStorage.getItem(LOGO_KEY) || "").trim();
          if(!raw) raw = DEFAULT_LOGO_URL;
          const url = normalizeUrlMaybe(raw);
          if(url){
            $logoImg.src = url;
            $logoImg.style.display = "block";
          }else{
            $logoImg.removeAttribute("src");
            $logoImg.style.display = "none";
          }
        }catch{
          $logoImg.style.display = "none";
        }
      }
      $logoUploadBtn.addEventListener("click", (e) => { e.stopPropagation(); });
      $logoSlot.addEventListener("click", () => { /* index에서는 입력 금지 */ });

      // ==========================================================
      // storage helpers
      // ==========================================================
      const LS_KEY = "imgmap_multi_v700";
      const nowISO = () => new Date().toISOString();
      const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
      const clamp01 = v => clamp(v,0,1);
      const uid = () => Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
      function safeParse(json, fallback){ try { return JSON.parse(json); } catch { return fallback; } }
      function saveState(){
        state._updatedAt = Date.now();
        state._updatedAtISO = new Date().toISOString();
        try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){ console.warn(e); }
      }
      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, c => ({
          '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
        }[c]));
      }
      function isValidUrl(url){ try { new URL(url, location.href); return true; } catch { return false; } }

      // ==========================================================
      // model defaults
      // ==========================================================
      const DEFAULT_CATEGORIES = [
        { name:"boss",   color:"#ff6b6b" },
        { name:"gather", color:"#ffd43b" },
        { name:"quest",  color:"#66d9e8" },
        { name:"hunt",   color:"#e6edf3" },
      ];

      const DEFAULT_MARKER_RADIUS_PX = 10;
      const DEFAULT_LABEL_COLOR = "#e6edf3";
      const DEFAULT_LABEL_WEIGHT = 900;
      const LABEL_SIZE_RATIO = 1.5;
      const calcLabelSizeFromRadius = (r) => Math.round(r * LABEL_SIZE_RATIO);

      const defaultState = {
        ui: {
          admin:false,
          selectedCategory:"",
          selectedMarkerId:"",
          lastCreatedMarkerId:"",
          activePaintColor:"",
          createCategory:"",
          createGroupId:0,
          createColorOverride:"",
          insertAfterMarkerId:"",
          dimmedMarkerIds: [],
        },
        currentGameId: "",
        currentPageId: "",
        games: [
          {
            id: uid(),
            name: "Map Demo",
            categories: structuredClone(DEFAULT_CATEGORIES),
            pages: [
              { id: uid(), name: "1번마을", map: { imageKey:"", imageUrl: DEFAULT_MAP_IMAGE_URL, width:2200, height:1400 }, markers: [], links: [] }
            ]
          }
        ]
      };

      const loaded = safeParse(localStorage.getItem(LS_KEY) || "", null);
      const state = (loaded && loaded.games && Array.isArray(loaded.games)) ? loaded : structuredClone(defaultState);
      if(!state.ui) state.ui = structuredClone(defaultState.ui);
      if(!Array.isArray(state.ui.dimmedMarkerIds)) state.ui.dimmedMarkerIds = [];
      if(!Array.isArray(state.games) || state.games.length === 0) state.games = structuredClone(defaultState.games);

      for(const g of state.games){
        if(!g.id) g.id = uid();
        if(typeof g.name !== "string") g.name = "Game";
        if(!Array.isArray(g.categories) || g.categories.length === 0) g.categories = structuredClone(DEFAULT_CATEGORIES);
        if(!Array.isArray(g.pages) || g.pages.length === 0){
          g.pages = [{ id: uid(), name:"1번마을", map:{imageKey:"", imageUrl:DEFAULT_MAP_IMAGE_URL, width:2200, height:1400}, markers:[], links:[] }];
        }
        for(const p of g.pages){
          if(!p.id) p.id = uid();
          if(typeof p.name !== "string") p.name = "Page";
          if(!p.map) p.map = { imageKey:"", imageUrl:DEFAULT_MAP_IMAGE_URL, width:2200, height:1400 };
          if(typeof p.map.imageUrl !== "string") p.map.imageUrl = DEFAULT_MAP_IMAGE_URL;
          if(!p.map.imageUrl.trim()) p.map.imageUrl = DEFAULT_MAP_IMAGE_URL;
          if(typeof p.map.width !== "number" || !isFinite(p.map.width)) p.map.width = 2200;
          if(typeof p.map.height !== "number" || !isFinite(p.map.height)) p.map.height = 1400;
          if(!Array.isArray(p.markers)) p.markers = [];
          if(!Array.isArray(p.links)) p.links = [];
        }
      }

      function getGameById(id){ return state.games.find(g => g.id === id) || null; }
      function getCurrentGame(){
        if(!state.currentGameId) state.currentGameId = state.games[0].id;
        const g = getGameById(state.currentGameId);
        if(!g){ state.currentGameId = state.games[0].id; return state.games[0]; }
        return g;
      }
      function getPageById(game, pid){ return game.pages.find(p => p.id === pid) || null; }
      function getCurrentPage(){
        const g = getCurrentGame();
        if(!state.currentPageId) state.currentPageId = g.pages[0].id;
        const p = getPageById(g, state.currentPageId);
        if(!p){ state.currentPageId = g.pages[0].id; return g.pages[0]; }
        return p;
      }
      function currentCategories(){ return getCurrentGame().categories; }
      function currentMarkers(){ return getCurrentPage().markers; }
      function currentLinks(){ return getCurrentPage().links; }
      function currentMap(){ return getCurrentPage().map; }

      function setCurrentPage(pageId){
        const g = getCurrentGame();
        const p = getPageById(g, pageId);
        if(!p) return;
        state.currentPageId = pageId;
        state.ui.selectedMarkerId = "";
        state.ui.dimmedMarkerIds = [];
        saveState();
        rebuildPageList();
        draw();
        loadMapImageForCurrentPage();
      }

      // ==========================================================
      // remote sync
      // ==========================================================
      async function tryFetchRemoteState(){
        try{
          const url = REMOTE_STATE_URL + (REMOTE_STATE_URL.includes("?") ? "&" : "?") + "v=" + Date.now();
          const res = await fetch(url, { cache:"no-store" });
          if(!res.ok) return null;
          const j = await res.json();
          if(!j || !Array.isArray(j.games)) return null;
          return j;
        }catch{ return null; }
      }

      function sanitizeLoadedStateLikeInit(s){
        if(!s.ui) s.ui = structuredClone(defaultState.ui);
        if(!Array.isArray(s.ui.dimmedMarkerIds)) s.ui.dimmedMarkerIds = [];
        if(!Array.isArray(s.games) || s.games.length === 0) return false;

        for(const g of s.games){
          if(!g.id) g.id = uid();
          if(typeof g.name !== "string") g.name = "Game";
          if(!Array.isArray(g.categories) || g.categories.length === 0) g.categories = structuredClone(DEFAULT_CATEGORIES);
          if(!Array.isArray(g.pages) || g.pages.length === 0){
            g.pages = [{ id: uid(), name:"1번마을", map:{imageKey:"", imageUrl:DEFAULT_MAP_IMAGE_URL, width:2200, height:1400}, markers:[], links:[] }];
          }
          for(const p of g.pages){
            if(!p.id) p.id = uid();
            if(typeof p.name !== "string") p.name = "Page";
            if(!p.map) p.map = { imageKey:"", imageUrl:DEFAULT_MAP_IMAGE_URL, width:2200, height:1400 };
            if(typeof p.map.imageUrl !== "string") p.map.imageUrl = DEFAULT_MAP_IMAGE_URL;
            if(!p.map.imageUrl.trim()) p.map.imageUrl = DEFAULT_MAP_IMAGE_URL;
            if(typeof p.map.width !== "number" || !isFinite(p.map.width)) p.map.width = 2200;
            if(typeof p.map.height !== "number" || !isFinite(p.map.height)) p.map.height = 1400;
            if(!Array.isArray(p.markers)) p.markers = [];
            if(!Array.isArray(p.links)) p.links = [];
          }
        }
        return true;
      }

      async function syncStateFromRemoteIfNewer(){
        if(IS_ADMIN_PAGE) return;
        const remote = await tryFetchRemoteState();
        if(!remote) return;

        const remoteAt = Number(remote._updatedAt || 0);
        const localAt = Number(state._updatedAt || 0);
        if(remoteAt && remoteAt <= localAt) return;

        const keepDim = Array.isArray(state.ui?.dimmedMarkerIds) ? [...state.ui.dimmedMarkerIds] : [];
        if(!sanitizeLoadedStateLikeInit(remote)) return;

        state.games = remote.games;
        state.currentGameId = remote.currentGameId || (remote.games[0]?.id || state.currentGameId);
        state.currentPageId = remote.currentPageId || (remote.games[0]?.pages?.[0]?.id || state.currentPageId);
        state.ui = remote.ui || state.ui;
        state.ui.admin = false;
        state.ui.dimmedMarkerIds = keepDim;

        state._updatedAt = remoteAt || Date.now();
        state._updatedAtISO = remote._updatedAtISO || new Date(state._updatedAt).toISOString();

        try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){ console.warn(e); }

        rebuildPageList();
        await loadMapImageForCurrentPage();
        draw();
      }

      // ==========================================================
      // DOM
      // ==========================================================
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const centerStage = document.getElementById("centerStage");

      const adminToggleWrap = document.getElementById("adminToggleWrap");
      const modeBadge = document.getElementById("modeBadge");
      const categoryBar = document.getElementById("categoryBar");
      const countInfo = document.getElementById("countInfo");

      const pageBadge = document.getElementById("pageBadge");
      const addPageBtn = document.getElementById("addPageBtn");
      const pageList = document.getElementById("pageList");

      const selectedHeader = document.getElementById("selectedHeader");
      const youtubeBox = document.getElementById("youtubeBox");

      const hoverOverlay = document.getElementById("hoverOverlay");
      const hoverYt = document.getElementById("hoverYt");
      const hoverMemo = document.getElementById("hoverMemo");

      const resetDimBtn = document.getElementById("resetDimBtn");

      const gameTitleBtn = document.getElementById("gameTitleBtn");
      const gameTitleText = document.getElementById("gameTitleText");
      const gameDrop = document.getElementById("gameDrop");

      // index는 관리자 토글 숨김 + 강제 USER
      adminToggleWrap.style.display = "none";
      state.ui.admin = false;
      modeBadge.textContent = "USER";

      // ==========================================================
      // map image (URL only for index)
      // ==========================================================
      const mapImg = new Image();
      mapImg.crossOrigin = "anonymous";
      let mapImgReady = false;

      async function loadMapImageForCurrentPage(){
        mapImgReady = false;
        const mp = currentMap();
        let url = (mp.imageUrl || "").trim();
        if(!url) url = DEFAULT_MAP_IMAGE_URL;

        const abs = new URL(url, location.href).toString();
        mapImg.onload = () => {
          mapImgReady = true;
          mp.width = mapImg.naturalWidth || mapImg.width;
          mp.height = mapImg.naturalHeight || mapImg.height;
          saveState();
          resetView();
          draw();
        };
        mapImg.onerror = () => { mapImgReady = false; draw(); };
        mapImg.src = abs + (abs.includes("?") ? "&" : "?") + "v=" + Date.now();
      }

      // ==========================================================
      // view
      // ==========================================================
      const view = { scale:1, minScale:0.05, maxScale:10, offsetX:0, offsetY:0 };
      const markerScaleDenom = () => (SCALE_MARKERS_WITH_ZOOM ? 1 : view.scale);

      function clampViewToBounds(){
        const rect = canvas.getBoundingClientRect();
        const cw = rect.width, ch = rect.height;
        const mp = currentMap();
        const mw = mp.width * view.scale;
        const mh = mp.height * view.scale;

        if(mw <= cw) view.offsetX = (cw - mw) / 2;
        else view.offsetX = clamp(view.offsetX, cw - mw, 0);

        if(mh <= ch) view.offsetY = (ch - mh) / 2;
        else view.offsetY = clamp(view.offsetY, ch - mh, 0);
      }

      function resizeCanvas(){
        const rect = canvas.getBoundingClientRect();
        const dpr = isIOS ? 1 : (window.devicePixelRatio || 1);
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        clampViewToBounds();
        draw();
      }
      window.addEventListener("resize", resizeCanvas);

      function worldToScreen(wx, wy){ return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY }; }
      function screenToWorld(sx, sy){ return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale }; }

      function resetView(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const mp = currentMap();
        const s = Math.min(w / mp.width, h / mp.height) * 0.95;
        view.scale = clamp(s, view.minScale, view.maxScale);
        view.offsetX = (w - mp.width * view.scale) / 2;
        view.offsetY = (h - mp.height * view.scale) / 2;
        clampViewToBounds();
      }

      // ==========================================================
      // UI
      // ==========================================================
      function getCategoryColor(name){
        const c = currentCategories().find(x => x.name === name);
        return c?.color || "#e6edf3";
      }
      function getMarkerColor(m){
        const ov = (m.colorOverride || "").trim();
        return ov ? ov : getCategoryColor(m.category);
      }
      function getMarkerLabel(m){
        const t = (m.title || "").trim();
        return t ? t : (m.category || "").trim();
      }
      function getUserYoutubeDisplay(m){
        const name = (m.youtubeLabel || "").trim();
        if(name) return name;
        const t = (m.title || "").trim();
        if(t) return t;
        return "유튜브";
      }

      function rebuildCategoryBar(){
        categoryBar.innerHTML = "";
        categoryBar.appendChild(makeCatButton("전체", "", "#223042"));
        for(const c of currentCategories()){
          categoryBar.appendChild(makeCatButton(c.name, c.name, c.color || "#e6edf3"));
        }
      }
      function makeCatButton(label, value, color){
        const btn = document.createElement("button");
        btn.className = "catBtn" + ((state.ui.selectedCategory === value) ? " active" : "");
        const dot = document.createElement("span");
        dot.className = "catDot";
        dot.style.background = color || "#223042";
        btn.appendChild(dot);
        const txt = document.createElement("span");
        txt.textContent = label;
        btn.appendChild(txt);

        btn.addEventListener("click", () => {
          state.ui.selectedCategory = value;
          saveState();
          rebuildCategoryBar();
          draw();
        });
        return btn;
      }
      function getVisibleMarkers(){
        const cat = state.ui.selectedCategory || "";
        if(!cat) return currentMarkers();
        return currentMarkers().filter(m => m.category === cat);
      }

      function rebuildPageList(){
        const g = getCurrentGame();
        const curPage = getCurrentPage();
        pageBadge.textContent = `${g.name} / ${curPage.name}`;
        pageList.innerHTML = "";

        for(const p of g.pages){
          const btn = document.createElement("button");
          btn.className = "pageBtn" + (p.id === curPage.id ? " active" : "");
          btn.type = "button";
          btn.innerHTML = `<div class="name">${escapeHtml(p.name || "Page")}</div>`;
          btn.addEventListener("click", () => setCurrentPage(p.id));
          pageList.appendChild(btn);
        }
      }
      addPageBtn.style.display = "none"; // index: 숨김

      function renderSelectedPanel(){
        const m = currentMarkers().find(x => x.id === state.ui.selectedMarkerId);
        if(!m){
          selectedHeader.textContent = "선택한 마커";
          youtubeBox.textContent = "-";
          return;
        }
        const name = (m.title || "").trim() || "(이름 없음)";
        selectedHeader.textContent = `선택한 마커: ${name}`;
        const url = (m.youtubeUrl || "").trim();
        const display = getUserYoutubeDisplay(m);
        if(url && isValidUrl(url)){
          youtubeBox.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(display)}</a>`;
        }else{
          youtubeBox.textContent = display ? display : "없음";
        }
      }

      // ==========================================================
      // overlay
      // ==========================================================
      let overlayPinned = false;
      let pinnedMarkerId = "";

      function hideHoverOverlay(force=false){
        if(force){ hoverOverlay.style.display = "none"; return; }
        if(overlayPinned) return;
        hoverOverlay.style.display = "none";
      }
      function unpinOverlay(){
        overlayPinned = false;
        pinnedMarkerId = "";
        hideHoverOverlay(true);
      }
      function positionOverlay(clientX, clientY){
        const stageRect = centerStage.getBoundingClientRect();
        const pad = 10;
        let x = clientX - stageRect.left + 16;
        let y = clientY - stageRect.top + 16;
        hoverOverlay.style.left = x + "px";
        hoverOverlay.style.top = y + "px";
        hoverOverlay.style.display = "block";
        const overlayRect = hoverOverlay.getBoundingClientRect();
        const maxX = stageRect.width - overlayRect.width - pad;
        const maxY = stageRect.height - overlayRect.height - pad;
        x = clamp(x, pad, Math.max(pad, maxX));
        y = clamp(y, pad, Math.max(pad, maxY));
        hoverOverlay.style.left = x + "px";
        hoverOverlay.style.top = y + "px";
      }
      function renderOverlayForMarker(m){
        hoverMemo.value = m.memo || "";
        const url = (m.youtubeUrl || "").trim();
        if(url && isValidUrl(url)){
          const displayName = escapeHtml(getUserYoutubeDisplay(m));
          hoverYt.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${displayName}</a>`;
        }else{
          hoverYt.innerHTML = `<span class="muted">유튜브 없음</span>`;
        }
      }
      function showHoverOverlayForMarker(m, clientX, clientY){
        if(overlayPinned) return;
        renderOverlayForMarker(m);
        positionOverlay(clientX, clientY);
      }
      function showPinnedOverlayForMarker(m, clientX, clientY){
        overlayPinned = true;
        pinnedMarkerId = m.id;
        renderOverlayForMarker(m);
        positionOverlay(clientX, clientY);
      }

      // ==========================================================
      // hit test
      // ==========================================================
      function getPointerPos(evt){
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }
      function worldToMarkerScreen(m){
        const mp = currentMap();
        return worldToScreen(m.x * mp.width, m.y * mp.height);
      }
      function findMarkerAtScreen(sx, sy){
        const list = getVisibleMarkers();
        for(let i=list.length-1; i>=0; i--){
          const m = list[i];
          const p = worldToMarkerScreen(m);
          const rPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
          const rScreen = (rPx * view.scale) / markerScaleDenom();
          const dx = sx - p.x, dy = sy - p.y;
          if(dx*dx + dy*dy <= rScreen*rScreen) return m;
        }
        return null;
      }
      function getLabelRectScreen(m){
        const p = worldToMarkerScreen(m);
        const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
        const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
        const label = getMarkerLabel(m);
        const denom = markerScaleDenom();
        const sizeScreen = (sizePx * view.scale) / denom;

        ctx.save();
        ctx.font = `900 ${sizeScreen}px system-ui`;
        const w = ctx.measureText(label).width;
        ctx.restore();

        const gapScreen = (10 * view.scale) / denom;
        const rScreen = (radiusPx * view.scale) / denom;
        const x = p.x + rScreen + gapScreen;
        const yMid = p.y;
        const h = sizeScreen * 1.2;

        return { x, y: yMid - h/2, w, h };
      }
      function findMarkerLabelAtScreen(sx, sy){
        const list = getVisibleMarkers();
        for(let i=list.length-1; i>=0; i--){
          const m = list[i];
          const r = getLabelRectScreen(m);
          if(sx >= r.x && sx <= (r.x + r.w) && sy >= r.y && sy <= (r.y + r.h)) return m;
        }
        return null;
      }

      // ==========================================================
      // zoom
      // ==========================================================
      canvas.addEventListener("wheel", (evt) => {
        evt.preventDefault();
        const { x:sx, y:sy } = getPointerPos(evt);
        const before = screenToWorld(sx, sy);

        const delta = -evt.deltaY;
        const zoomFactor = Math.exp(delta * 0.0015);
        view.scale = clamp(view.scale * zoomFactor, view.minScale, view.maxScale);

        const after = screenToWorld(sx, sy);
        view.offsetX += (after.x - before.x) * view.scale;
        view.offsetY += (after.y - before.y) * view.scale;

        clampViewToBounds();
        draw();
      }, { passive:false });

      // ==========================================================
      // ✅ 핵심 수정: index 드래그 패닝 확실하게
      // ==========================================================
      let isPanning = false;
      let panStart = { x:0, y:0 };
      let viewStart = { ox:0, oy:0 };

      let userDragActive = false;
      let userDragMoved = false;
      let userDownMarkerId = "";
      let userDownScreen = { x:0, y:0 };
      const USER_DRAG_THRESHOLD = 3;
      let userJustDragged = false;

      canvas.addEventListener("mousedown", (evt) => {
        if(evt.button !== 0) return;
        evt.preventDefault();

        const { x:sx, y:sy } = getPointerPos(evt);

        userDragActive = true;
        userDragMoved = false;
        userJustDragged = false;
        userDownScreen = { x:sx, y:sy };

        const m = findMarkerAtScreen(sx, sy);
        userDownMarkerId = m ? m.id : "";

        isPanning = true;
        panStart = { x:sx, y:sy };
        viewStart = { ox:view.offsetX, oy:view.offsetY };

        if(m){
          state.ui.selectedMarkerId = m.id;
          renderSelectedPanel();
        }
      });

      canvas.addEventListener("mousemove", (evt) => {
        const { x:sx, y:sy } = getPointerPos(evt);

        // ✅ 유저모드: 누른 채 움직이면 무조건 패닝 (이게 핵심)
        if(userDragActive && isPanning){
          evt.preventDefault();

          const dx0 = sx - userDownScreen.x;
          const dy0 = sy - userDownScreen.y;
          if(!userDragMoved && (Math.abs(dx0) > USER_DRAG_THRESHOLD || Math.abs(dy0) > USER_DRAG_THRESHOLD)){
            userDragMoved = true;
            if(!overlayPinned) hideHoverOverlay(true);
          }

          // ✅ moved 여부와 상관없이 지도 이동
          const pdx = sx - panStart.x;
          const pdy = sy - panStart.y;
          view.offsetX = viewStart.ox + pdx;
          view.offsetY = viewStart.oy + pdy;
          clampViewToBounds();
          draw();
          return;
        }

        // hover (드래그 중이 아닐 때만)
        if(!overlayPinned && !userDragMoved){
          const mLabel = findMarkerLabelAtScreen(sx, sy);
          if(mLabel) showHoverOverlayForMarker(mLabel, evt.clientX, evt.clientY);
          else hideHoverOverlay();
        }
      });

      window.addEventListener("mouseup", () => {
        if(userDragActive){
          if(userDragMoved){
            userJustDragged = true;
            setTimeout(() => { userJustDragged = false; }, 0);
          }else{
            // 드래그가 아니라 "클릭"이면 마커 토글(불투명)
            if(userDownMarkerId){
              const id = userDownMarkerId;
              const arr = Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : [];
              const idx = arr.indexOf(id);
              if(idx >= 0) arr.splice(idx, 1);
              else arr.push(id);
              state.ui.dimmedMarkerIds = arr;

              saveState();
              renderSelectedPanel();
              draw();
            }
          }
        }

        userDragActive = false;
        userDragMoved = false;
        userDownMarkerId = "";
        isPanning = false;
      });

      canvas.addEventListener("click", (evt) => {
        if(userJustDragged) return;

        const { x:sx, y:sy } = getPointerPos(evt);
        const mLabel = findMarkerLabelAtScreen(sx, sy);
        if(mLabel){
          showPinnedOverlayForMarker(mLabel, evt.clientX, evt.clientY);
        }else{
          if(overlayPinned){ unpinOverlay(); draw(); }
        }
      });

      // ==========================================================
      // reset dim
      // ==========================================================
      resetDimBtn.addEventListener("click", () => {
        state.ui.dimmedMarkerIds = [];
        saveState();
        draw();
      });

      // ==========================================================
      // draw
      // ==========================================================
      function drawBackgroundGrid(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        ctx.save();
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = "#070b12";
        ctx.fillRect(0,0,w,h);
        ctx.globalAlpha = 0.10;
        ctx.strokeStyle = "#243447";
        for(let x=0; x<w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
        for(let y=0; y<h; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
        ctx.restore();
      }

      function buildNumberMap(){
        // 간단: 생성 순서대로 1.. (체인번호 필요하면 기존 로직 붙이면 됨)
        const map = new Map();
        const markers = currentMarkers().slice().sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""));
        for(let i=0;i<markers.length;i++) map.set(markers[i].id, i+1);
        return map;
      }

      function draw(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;

        drawBackgroundGrid();

        const numMap = buildNumberMap();
        const mp = currentMap();
        const dimSet = new Set(Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : []);

        ctx.save();
        ctx.translate(view.offsetX, view.offsetY);
        ctx.scale(view.scale, view.scale);

        if(mapImgReady){
          ctx.drawImage(mapImg, 0, 0, mp.width, mp.height);
        }else{
          ctx.fillStyle = "#0d131c";
          ctx.fillRect(0,0,mp.width, mp.height);
        }

        const visible = getVisibleMarkers();
        countInfo.textContent = `표시 중 마커: ${visible.length} / 페이지 전체: ${currentMarkers().length}`;

        // markers
        for(const m of visible){
          const wx = m.x * mp.width;
          const wy = m.y * mp.height;

          const color = getMarkerColor(m);
          const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
          const denom = markerScaleDenom();
          const r = radiusPx / denom;

          const isDimmed = dimSet.has(m.id);
          const alpha = isDimmed ? 0.30 : 1.0;

          ctx.save();
          ctx.translate(wx, wy);

          // circle + number (dim 적용)
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(0,0,r,0,Math.PI*2);
          ctx.fill();
          ctx.lineWidth = 2 / denom;
          ctx.strokeStyle = "#0b0f14";
          ctx.stroke();

          const num = numMap.get(m.id);
          if(num != null){
            ctx.save();
            ctx.fillStyle = "#000";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const fs = Math.max((radiusPx * 0.95) / denom, 9 / denom);
            ctx.font = `900 ${fs}px system-ui`;
            ctx.fillText(String(num), 0, 0);
            ctx.restore();
          }

          // label (항상 100% 불투명)
          ctx.globalAlpha = 1.0;
          const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
          ctx.fillStyle = DEFAULT_LABEL_COLOR;
          ctx.font = `900 ${sizePx / denom}px system-ui`;
          ctx.textBaseline = "middle";
          ctx.textAlign = "left";
          const gap = 10 / denom;
          ctx.fillText(getMarkerLabel(m), r + gap, 0);

          ctx.restore();
        }

        ctx.restore();
      }

      // ==========================================================
      // init
      // ==========================================================
      function refreshHeaderTitle(){
        const g = getCurrentGame();
        gameTitleText.textContent = g.name || "Map Demo";
      }
      function rebuildGameDrop(){ gameDrop.innerHTML = ""; } // index에선 드롭다운 편집/추가 막아둠
      function refreshAll(){
        refreshHeaderTitle();
        rebuildGameDrop();
        rebuildPageList();
        rebuildCategoryBar();
        renderSelectedPanel();
      }

      async function init(){
        getCurrentGame();
        getCurrentPage();
        refreshAll();
        loadLogo();
        resizeCanvas();
        resetView();
        await loadMapImageForCurrentPage();
        draw();

        // remote sync
        syncStateFromRemoteIfNewer();
        setInterval(syncStateFromRemoteIfNewer, REMOTE_SYNC_INTERVAL_MS);
        document.addEventListener("visibilitychange", () => {
          if(document.visibilityState === "visible") syncStateFromRemoteIfNewer();
        });
      }

      init();
    })();
  </script>
</body>
</html>
