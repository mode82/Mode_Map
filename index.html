<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Multi-Map Demo v7.0.0</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      --topSlotW: 150px;
      --topSlotH: 38px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }

    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.9);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      flex-wrap: wrap;
    }

    button, input, select, textarea{
      background: rgba(16,24,38,.65);
      border: 1px solid rgba(39,52,74,.9);
      color: var(--text);
      border-radius: var(--r14);
      padding:9px 11px;
      font-size:14px;
      outline:none;
      transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }

    button{ cursor:pointer; font-weight:800; }
    button:hover{ border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 3px rgba(124,196,255,.12); }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; box-shadow:none; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(39,52,74,.9);
      border-radius:999px;
      background: rgba(14,22,38,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.6);
    }

    .muted{ color: var(--muted); font-size:12px; }
    .k{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

    .wrap{
      display:grid;
      grid-template-columns: 1fr 380px;
      height: calc(100vh - 56px);
    }

    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
      border-left:1px solid rgba(31,42,58,.85);
    }

    .center{ position:relative; overflow:hidden; }
    #canvas{ width:100%; height:100%; display:block; background:#0b0f14; }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }

    .section h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color: rgba(231,238,248,.92);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .hr{ height:1px; background: rgba(31,42,58,.9); margin:12px 0; }

    .catGrid{ display:flex; flex-wrap:wrap; gap:8px; }
    .catBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .catDot{
      width:10px;
      height:10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-block;
    }
    .catBtn.active{
      border-color: rgba(124,196,255,.9);
      box-shadow: 0 0 0 3px rgba(124,196,255,.14);
    }

    .linkBox{
      padding:12px 12px;
      border:1px solid rgba(39,52,74,.9);
      border-radius: var(--r16);
      background: rgba(8,12,20,.55);
      word-break:break-all;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    #hoverOverlay{
      position:absolute;
      display:none;
      z-index:50;
      background: rgba(10,16,28,.78);
      border: 1px solid rgba(124,196,255,.18);
      border-radius: var(--r16);
      padding:10px 12px;
      max-width:min(420px, 84vw);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      pointer-events:auto;
    }
    #hoverOverlay .memoLabel{
      font-size:12px;
      color: var(--muted);
      margin-bottom:6px;
      font-weight:800;
      letter-spacing:.2px;
    }
    #hoverOverlay textarea{
      width: 100%;
      resize:none;
      line-height:1.35;
      padding:10px 10px;
      border-radius:12px;
      margin-bottom:10px;
      font-size:13px;
    }
    #hoverOverlay textarea[readonly]{ opacity: .95; }
    #hoverOverlay .yt{ font-size:14px; font-weight:900; letter-spacing:.2px; }
    #hoverOverlay .yt a{ color: rgba(231,238,248,.95); text-decoration:none; }
    #hoverOverlay .yt a:hover{ text-decoration: underline; }

    .resetDanger{
      border: 2px solid rgba(255,93,93,.92) !important;
      background: rgba(26,10,12,.45) !important;
      box-shadow: 0 0 0 4px rgba(255,93,93,.10);
      width:100%;
      padding:12px 12px;
      border-radius: var(--r16);
      font-weight:900;
    }

    /* Top slots (4칸) */
    .topSlots{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .topSlot{
      width: var(--topSlotW);
      height: var(--topSlotH);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      overflow:hidden;
      position:relative;
      flex: 0 0 auto;
    }
    .topSlot.placeholder{
      opacity: 0;
      pointer-events: none;
    }

    /* Logo slot */
    #logoSlot{
      padding: 0;
      justify-content: center;
      border: 0;
    }
    #logoImg{
      width:100%;
      height:100%;
      object-fit: contain;
      display:none;
      padding:4px;
    }

    /* Category 2 slot = AION2 (유저는 고정 표시만) */
    #cat2Slot .fixedTitle{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      letter-spacing:.2px;
      color: rgba(231,238,248,.92);
      user-select:none;
    }

    @media (max-width: 1100px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .panel{ border-left:none; border-top:1px solid rgba(31,42,58,.85); }
      #canvas{ height: 60vh; }
    }
  </style>
</head>

<body>
  <header>
    <div class="topSlots" id="topSlots">
      <!-- 1번: 로고 (보이게) -->
      <div class="topSlot" id="logoSlot" title="로고">
        <img id="logoImg" alt="logo" />
      </div>

      <!-- 2번: 아이온2 (보이게) -->
      <div class="topSlot" id="cat2Slot" title="아이온2">
        <div class="fixedTitle" id="gameFixedTitle">아이온2</div>
      </div>

      <!-- 3/4번: 자리만 확보 (숨김) -->
      <div class="topSlot placeholder" id="cat3Slot" aria-hidden="true"></div>
      <div class="topSlot placeholder" id="cat4Slot" aria-hidden="true"></div>
    </div>

    <span class="pill">
      <span class="badge">USER</span>
      <span class="muted">index</span>
    </span>
  </header>

  <div class="wrap">
    <div class="center" id="centerStage">
      <canvas id="canvas"></canvas>

      <div id="hoverOverlay">
        <div class="memoLabel">메모</div>
        <textarea id="hoverMemo" cols="10" rows="3" readonly></textarea>
        <div class="yt" id="hoverYt">-</div>
      </div>
    </div>

    <aside class="panel">
      <div class="section">
        <h3>카테고리</h3>
        <div class="catGrid" id="categoryBar"></div>
        <div class="muted" id="countInfo" style="margin-top:10px;">-</div>
      </div>

      <div class="section">
        <h3 id="selectedHeader">선택한 마커</h3>
        <div class="hr"></div>
        <div class="muted">유튜브</div>
        <div id="youtubeBox" class="linkBox" style="margin-top:8px;">-</div>
      </div>

      <div class="section">
        <button id="resetDimBtn" class="resetDanger" type="button">마커 초기화</button>
        <div class="muted" style="margin-top:10px; line-height:1.45;">
          • 클릭한 마커는 불투명(30%) 처리됩니다.<br/>
          • 이 버튼으로 전체 복구 가능합니다.
        </div>
      </div>
    </aside>
  </div>

  <script>
    if (typeof structuredClone !== "function") {
      window.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));
    }
  </script>

  <script>
    (() => {
      const IS_COARSE_POINTER = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;

      // ✅ 모바일에서 "예전 IDB 이미지"가 뜨는 원인 제거:
      // - index(유저)는 모바일에서 IDB 이미지 로드 금지 + URL만 사용
      const DISABLE_IDB_IMAGE_ON_MOBILE = IS_COARSE_POINTER;

      // ✅ 통일된 원격 state.json 경로
      const REMOTE_STATE_URL = new URL("./data/state.json", location.href).toString();

      const LS_KEY = "imgmap_multi_v700";
      const IDB_NAME = "imgmap_multi_db_v700";
      const IDB_STORE = "blobs";

      const nowISO = () => new Date().toISOString();
      const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
      const clamp01 = v => clamp(v,0,1);
      const uid = () => Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);

      function safeParse(json, fallback){
        try { return JSON.parse(json); } catch { return fallback; }
      }
      function escapeHtml(s){
        return String(s).replace(/[&<>"']/g, c => ({
          '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
        }[c]));
      }
      function isValidUrl(url){
        try { new URL(url, location.href); return true; } catch { return false; }
      }

      // Logo (admin과 동일 key)
      const LOGO_KEY = "mm_logo_url_v1";
      const $logoImg = document.getElementById("logoImg");
      function normalizeUrlMaybe(u){
        const v = String(u || "").trim();
        if(!v) return "";
        try { return new URL(v, location.href).toString(); } catch { return v; }
      }
      function loadLogo(){
        try{
          const raw = (localStorage.getItem(LOGO_KEY) || "").trim();
          const url = normalizeUrlMaybe(raw);
          if(url){
            $logoImg.src = url;
            $logoImg.style.display = "block";
          }else{
            $logoImg.removeAttribute("src");
            $logoImg.style.display = "none";
          }
        }catch{
          $logoImg.style.display = "none";
        }
      }

      // Default categories (fallback only)
      const DEFAULT_CATEGORIES = [
        { name:"boss",   color:"#ff6b6b" },
        { name:"gather", color:"#ffd43b" },
        { name:"quest",  color:"#66d9e8" },
        { name:"hunt",   color:"#e6edf3" },
      ];

      const DEFAULT_MARKER_RADIUS_PX = 10;
      const DEFAULT_LABEL_COLOR = "#e6edf3";
      const DEFAULT_LABEL_WEIGHT = 900;
      const LABEL_SIZE_RATIO = 1.5;
      const calcLabelSizeFromRadius = (r) => Math.round(r * LABEL_SIZE_RATIO);

      // state init
      const defaultState = {
        ui: {
          admin:false,
          selectedCategory:"",
          selectedMarkerId:"",
          dimmedMarkerIds: [],
        },
        currentGameId: "",
        currentPageId: "",
        games: [
          {
            id: uid(),
            name: "Map Demo",
            categories: structuredClone(DEFAULT_CATEGORIES),
            pages: [
              { id: uid(), name: "1번마을", map: { imageKey:"", imageUrl:"", width:2200, height:1400 }, markers: [], links: [] }
            ]
          }
        ]
      };

      const state = (() => {
        const loaded = safeParse(localStorage.getItem(LS_KEY) || "", null);
        if(loaded && loaded.games && Array.isArray(loaded.games)) return loaded;
        return structuredClone(defaultState);
      })();

      if(!state.ui) state.ui = structuredClone(defaultState.ui);
      state.ui.admin = false;
      if(!Array.isArray(state.ui.dimmedMarkerIds)) state.ui.dimmedMarkerIds = [];

      if(!Array.isArray(state.games) || state.games.length === 0) state.games = structuredClone(defaultState.games);
      for(const g of state.games){
        if(!g.id) g.id = uid();
        if(typeof g.name !== "string") g.name = "Game";
        if(!Array.isArray(g.categories) || g.categories.length === 0) g.categories = structuredClone(DEFAULT_CATEGORIES);
        if(!Array.isArray(g.pages) || g.pages.length === 0){
          g.pages = [{ id: uid(), name:"1번마을", map:{imageKey:"", imageUrl:"", width:2200, height:1400}, markers:[], links:[] }];
        }
        for(const p of g.pages){
          if(!p.id) p.id = uid();
          if(typeof p.name !== "string") p.name = "Page";
          if(!p.map) p.map = { imageKey:"", imageUrl:"", width:2200, height:1400 };
          if(typeof p.map.imageKey !== "string") p.map.imageKey = "";
          if(typeof p.map.imageUrl !== "string") p.map.imageUrl = "";
          if(typeof p.map.width !== "number" || !isFinite(p.map.width)) p.map.width = 2200;
          if(typeof p.map.height !== "number" || !isFinite(p.map.height)) p.map.height = 1400;
          if(!Array.isArray(p.markers)) p.markers = [];
          if(!Array.isArray(p.links)) p.links = [];
        }
      }

      function saveState(){
        try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){ console.warn(e); }
      }

      function getGameById(id){ return state.games.find(g => g.id === id) || null; }
      function getCurrentGame(){
        if(!state.currentGameId) state.currentGameId = state.games[0].id;
        const g = getGameById(state.currentGameId);
        if(!g){ state.currentGameId = state.games[0].id; return state.games[0]; }
        return g;
      }
      function getPageById(game, pid){ return game.pages.find(p => p.id === pid) || null; }
      function getCurrentPage(){
        const g = getCurrentGame();
        if(!state.currentPageId) state.currentPageId = g.pages[0].id;
        const p = getPageById(g, state.currentPageId);
        if(!p){ state.currentPageId = g.pages[0].id; return g.pages[0]; }
        return p;
      }
      function currentCategories(){ return getCurrentGame().categories; }
      function currentMarkers(){ return getCurrentPage().markers; }
      function currentLinks(){ return getCurrentPage().links; }
      function currentMap(){ return getCurrentPage().map; }

      function getCategoryColor(name){
        const c = currentCategories().find(x => x.name === name);
        return c?.color || "#e6edf3";
      }
      function getMarkerColor(m){
        const ov = (m.colorOverride || "").trim();
        return ov ? ov : getCategoryColor(m.category);
      }
      function getMarkerLabel(m){
        const t = (m.title || "").trim();
        return t ? t : (m.category || "").trim();
      }
      function getUserYoutubeDisplay(m){
        const name = (m.youtubeLabel || "").trim();
        if(name) return name;
        const t = (m.title || "").trim();
        if(t) return t;
        return "유튜브";
      }

      // ===== Remote state sync (optional) =====
      // index는 로컬 state를 우선 사용하되, remote state.json이 있으면 갱신할 수 있게 구현
      async function tryFetchRemoteState(){
        try{
          const res = await fetch(REMOTE_STATE_URL, { cache: "no-store" });
          if(!res.ok) return false;
          const json = await res.json();
          if(!json || !Array.isArray(json.games)) return false;
          // ui는 유저모드로 강제
          json.ui = json.ui || {};
          json.ui.admin = false;
          if(!Array.isArray(json.ui.dimmedMarkerIds)) json.ui.dimmedMarkerIds = [];
          localStorage.setItem(LS_KEY, JSON.stringify(json));
          // state 참조 갱신 (간단히 reload)
          location.reload();
          return true;
        }catch{
          return false;
        }
      }

      // ===== IndexedDB (for PC only) =====
      function openDB(){
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(IDB_NAME, 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if(!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      async function idbGet(key){
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          const req = tx.objectStore(IDB_STORE).get(key);
          req.onsuccess = () => { db.close(); resolve(req.result || null); };
          req.onerror = () => { db.close(); reject(req.error); };
        });
      }

      // ===== Canvas / View =====
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const centerStage = document.getElementById("centerStage");

      const categoryBar = document.getElementById("categoryBar");
      const countInfo = document.getElementById("countInfo");

      const selectedHeader = document.getElementById("selectedHeader");
      const youtubeBox = document.getElementById("youtubeBox");

      const hoverOverlay = document.getElementById("hoverOverlay");
      const hoverYt = document.getElementById("hoverYt");
      const hoverMemo = document.getElementById("hoverMemo");

      const resetDimBtn = document.getElementById("resetDimBtn");

      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      const SCALE_MARKERS_WITH_ZOOM = IS_COARSE_POINTER; // 모바일은 같이 스케일

      const view = { scale:1, minScale:0.05, maxScale:10, offsetX:0, offsetY:0 };
      const markerScaleDenom = () => (SCALE_MARKERS_WITH_ZOOM ? 1 : view.scale);

      function clampViewToBounds(){
        const rect = canvas.getBoundingClientRect();
        const cw = rect.width, ch = rect.height;
        const mp = currentMap();
        const mw = mp.width * view.scale;
        const mh = mp.height * view.scale;

        if(mw <= cw) view.offsetX = (cw - mw) / 2;
        else view.offsetX = clamp(view.offsetX, cw - mw, 0);

        if(mh <= ch) view.offsetY = (ch - mh) / 2;
        else view.offsetY = clamp(view.offsetY, ch - mh, 0);
      }

      function resizeCanvas(){
        const rect = canvas.getBoundingClientRect();
        const dpr = isIOS ? 1 : (window.devicePixelRatio || 1);
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
        clampViewToBounds();
        draw();
      }
      window.addEventListener("resize", resizeCanvas);

      function worldToScreen(wx, wy){
        return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY };
      }
      function screenToWorld(sx, sy){
        return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale };
      }

      function resetView(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        const mp = currentMap();
        const mw = mp.width, mh = mp.height;
        const s = Math.min(w / mw, h / mh) * 0.95;
        view.scale = clamp(s, view.minScale, view.maxScale);
        view.offsetX = (w - mw * view.scale) / 2;
        view.offsetY = (h - mh * view.scale) / 2;
        clampViewToBounds();
      }

      // ===== Map image load (핵심) =====
      const mapImg = new Image();
      mapImg.crossOrigin = "anonymous";
      let mapImgReady = false;
      let mapObjectUrl = null;

      function currentMapImageKey(){
        const g = getCurrentGame();
        const p = getCurrentPage();
        return `mapimg_${g.id}_${p.id}`;
      }

      async function loadMapImageForCurrentPage(){
        mapImgReady = false;
        if(mapObjectUrl){ URL.revokeObjectURL(mapObjectUrl); mapObjectUrl = null; }

        const mp = currentMap();
        const url = (mp.imageUrl || "").trim();

        // ✅ URL이 있으면 (PC/모바일 공통) URL만 로드
        if(url && isValidUrl(url)){
          const abs = new URL(url, location.href).toString();
          mapImg.onload = () => {
            mapImgReady = true;
            mp.width = mapImg.naturalWidth || mapImg.width;
            mp.height = mapImg.naturalHeight || mapImg.height;
            saveState();
            resetView();
            draw();
          };
          mapImg.onerror = () => { mapImgReady = false; draw(); };
          mapImg.src = abs + (abs.includes("?") ? "&" : "?") + "v=" + Date.now();
          return;
        }

        // ✅ 모바일은 IDB 로드 금지 → 예전 이미지가 절대 뜨지 않음
        if(DISABLE_IDB_IMAGE_ON_MOBILE){
          mapImgReady = false;
          draw();
          return;
        }

        // PC에서만 IDB fallback
        const key = currentMapImageKey();
        const blob = await idbGet(key).catch(()=>null);
        if(blob){
          mapObjectUrl = URL.createObjectURL(blob);
          mapImg.onload = () => {
            mapImgReady = true;
            mp.width = mapImg.naturalWidth || mapImg.width;
            mp.height = mapImg.naturalHeight || mapImg.height;
            saveState();
            resetView();
            draw();
          };
          mapImg.onerror = () => { mapImgReady = false; draw(); };
          mapImg.src = mapObjectUrl;
          return;
        }

        mapImgReady = false;
        draw();
      }

      // ===== Categories UI =====
      function rebuildCategoryBar(){
        categoryBar.innerHTML = "";
        categoryBar.appendChild(makeCatButton("전체", "", "#223042"));
        for(const c of currentCategories()){
          categoryBar.appendChild(makeCatButton(c.name, c.name, c.color || "#e6edf3"));
        }
      }

      function makeCatButton(label, value, color){
        const btn = document.createElement("button");
        btn.className = "catBtn" + ((state.ui.selectedCategory === value) ? " active" : "");

        const dot = document.createElement("span");
        dot.className = "catDot";
        dot.style.background = color || "#223042";
        btn.appendChild(dot);

        const txt = document.createElement("span");
        txt.textContent = label;
        btn.appendChild(txt);

        btn.addEventListener("click", () => {
          state.ui.selectedCategory = value;
          saveState();
          rebuildCategoryBar();
          draw();
          renderSelectedPanel();
        });

        return btn;
      }

      function getVisibleMarkers(){
        const cat = state.ui.selectedCategory || "";
        if(!cat) return currentMarkers();
        return currentMarkers().filter(m => m.category === cat);
      }

      // ===== Marker numbering (체인 기반) =====
      function getSortedGroupMarkers(groupId){
        return currentMarkers()
          .filter(x => Number(x.groupId||0) === Number(groupId||0))
          .sort((a,b) => (a.createdAt||"").localeCompare(b.createdAt||""));
      }
      function computeChainsForGroup(groupId){
        const list = getSortedGroupMarkers(groupId);
        const chains = [];
        let chainIndex = -1;
        for(let i=0;i<list.length;i++){
          const m = list[i];
          const isStart = (i===0) || !!m.chainStart;
          if(isStart){
            chainIndex++;
            chains.push({ groupId:Number(groupId||0), chainIndex, masterId:m.id, ids:[m.id] });
          }else{
            if(chainIndex < 0){
              chainIndex = 0;
              chains.push({ groupId:Number(groupId||0), chainIndex, masterId:m.id, ids:[m.id] });
            }else{
              chains[chainIndex].ids.push(m.id);
            }
          }
        }
        return chains;
      }
      function buildNumberMap(){
        const map = new Map();
        const markers = currentMarkers();
        const groups = new Set(markers.map(m => Number(m.groupId||0)));
        for(const g of groups){
          const chains = computeChainsForGroup(g);
          for(const ch of chains){
            const ids = ch.ids
              .map(id => markers.find(m => m.id === id))
              .filter(Boolean)
              .sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""))
              .map(m => m.id);
            for(let i=0;i<ids.length;i++) map.set(ids[i], i+1);
          }
        }
        return map;
      }

      // ===== Selected / hover overlay =====
      function renderSelectedPanel(){
        const m = currentMarkers().find(x => x.id === state.ui.selectedMarkerId);
        if(!m){
          selectedHeader.textContent = "선택한 마커";
          youtubeBox.textContent = "-";
          return;
        }
        const name = (m.title || "").trim() || "(이름 없음)";
        selectedHeader.textContent = `선택한 마커: ${name}`;

        const url = (m.youtubeUrl || "").trim();
        const display = getUserYoutubeDisplay(m);

        if(url && isValidUrl(url)){
          youtubeBox.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(display)}</a>`;
        }else{
          youtubeBox.textContent = display ? display : "없음";
        }
      }

      let overlayPinned = false;
      let pinnedMarkerId = "";

      function hideHoverOverlay(force=false){
        if(force){ hoverOverlay.style.display = "none"; return; }
        if(overlayPinned) return;
        hoverOverlay.style.display = "none";
      }
      function positionOverlay(clientX, clientY){
        const stageRect = centerStage.getBoundingClientRect();
        const pad = 10;
        let x = clientX - stageRect.left + 16;
        let y = clientY - stageRect.top + 16;
        hoverOverlay.style.left = x + "px";
        hoverOverlay.style.top = y + "px";
        hoverOverlay.style.display = "block";
        const overlayRect = hoverOverlay.getBoundingClientRect();
        const maxX = stageRect.width - overlayRect.width - pad;
        const maxY = stageRect.height - overlayRect.height - pad;
        x = clamp(x, pad, Math.max(pad, maxX));
        y = clamp(y, pad, Math.max(pad, maxY));
        hoverOverlay.style.left = x + "px";
        hoverOverlay.style.top = y + "px";
      }
      function renderOverlayForMarker(m){
        hoverMemo.value = m.memo || "";
        const url = (m.youtubeUrl || "").trim();
        if(url && isValidUrl(url)){
          const displayName = escapeHtml(getUserYoutubeDisplay(m));
          hoverYt.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${displayName}</a>`;
        }else{
          hoverYt.innerHTML = `<span class="muted">유튜브 없음</span>`;
        }
      }

      // ===== Input =====
      function getPointerPos(evt){
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
      }

      function worldToMarkerScreen(m){
        const mp = currentMap();
        const wx = m.x * mp.width;
        const wy = m.y * mp.height;
        return worldToScreen(wx, wy);
      }

      function findMarkerAtScreen(sx, sy){
        const list = getVisibleMarkers();
        for(let i=list.length-1; i>=0; i--){
          const m = list[i];
          const p = worldToMarkerScreen(m);
          const rPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
          const dx = sx - p.x, dy = sy - p.y;
          if(dx*dx + dy*dy <= rPx*rPx) return m;
        }
        return null;
      }

      function getLabelRectScreen(m){
        const p = worldToMarkerScreen(m);
        const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
        const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
        const weight = (typeof m.labelWeight === "number" ? m.labelWeight : DEFAULT_LABEL_WEIGHT);
        const label = getMarkerLabel(m);

        ctx.save();
        ctx.font = `${weight} ${sizePx}px system-ui`;
        const w = ctx.measureText(label).width;
        ctx.restore();

        const gap = 10;
        const x = p.x + radiusPx + gap;
        const yMid = p.y;
        const h = sizePx * 1.2;

        return { x, y: yMid - h/2, w, h };
      }

      function findMarkerLabelAtScreen(sx, sy){
        const list = getVisibleMarkers();
        for(let i=list.length-1; i>=0; i--){
          const m = list[i];
          const r = getLabelRectScreen(m);
          if(sx >= r.x && sx <= (r.x + r.w) && sy >= r.y && sy <= (r.y + r.h)) return m;
        }
        return null;
      }

      // 줌/패닝
      canvas.addEventListener("wheel", (evt) => {
        evt.preventDefault();
        const { x:sx, y:sy } = getPointerPos(evt);
        const before = screenToWorld(sx, sy);

        const delta = -evt.deltaY;
        const zoomFactor = Math.exp(delta * 0.0015);

        view.scale = clamp(view.scale * zoomFactor, view.minScale, view.maxScale);

        const after = screenToWorld(sx, sy);
        view.offsetX += (after.x - before.x) * view.scale;
        view.offsetY += (after.y - before.y) * view.scale;

        clampViewToBounds();
        draw();
      }, { passive:false });

      let isPanning = false;
      let panStart = { x:0, y:0 };
      let viewStart = { ox:0, oy:0 };
      let didDrag = false;

      canvas.addEventListener("mousedown", (evt) => {
        const { x:sx, y:sy } = getPointerPos(evt);
        didDrag = false;

        if(evt.button !== 0) return;

        // 마커 클릭: dim 토글(한번 더 누르면 해제)
        const m = findMarkerAtScreen(sx, sy);
        if(m){
          state.ui.selectedMarkerId = m.id;

          const set = new Set(state.ui.dimmedMarkerIds || []);
          if(set.has(m.id)) set.delete(m.id);
          else set.add(m.id);
          state.ui.dimmedMarkerIds = [...set];

          saveState();
          renderSelectedPanel();
          draw();
          return;
        }

        // 라벨 hover/pin 처리: (유저 요구에 맞춰 라벨 영역에만 오버레이)
        // (mousedown에서는 pin만 처리, hover는 mousemove에서)
        const ml = findMarkerLabelAtScreen(sx, sy);
        if(ml){
          // 클릭 시 고정(pin)
          overlayPinned = true;
          pinnedMarkerId = ml.id;
          renderOverlayForMarker(ml);
          positionOverlay(evt.clientX, evt.clientY);
          return;
        }

        // 빈 공간: 오버레이 해제 + 패닝 시작
        overlayPinned = false;
        pinnedMarkerId = "";
        hideHoverOverlay(true);

        isPanning = true;
        panStart = { x:sx, y:sy };
        viewStart = { ox:view.offsetX, oy:view.offsetY };
      });

      canvas.addEventListener("mousemove", (evt) => {
        const { x:sx, y:sy } = getPointerPos(evt);

        if(isPanning){
          const dx = sx - panStart.x;
          const dy = sy - panStart.y;
          if(Math.abs(dx) > 2 || Math.abs(dy) > 2) didDrag = true;
          view.offsetX = viewStart.ox + dx;
          view.offsetY = viewStart.oy + dy;
          clampViewToBounds();
          draw();
          return;
        }

        // hover overlay: 라벨 위에 있을 때만(아이콘 X)
        if(overlayPinned){
          const pm = currentMarkers().find(x => x.id === pinnedMarkerId);
          if(!pm){
            overlayPinned = false;
            pinnedMarkerId = "";
            hideHoverOverlay(true);
          }
          return;
        }

        const ml = findMarkerLabelAtScreen(sx, sy);
        if(ml){
          renderOverlayForMarker(ml);
          positionOverlay(evt.clientX, evt.clientY);
        }else{
          hideHoverOverlay();
        }
      });

      window.addEventListener("mouseup", () => {
        isPanning = false;
      });

      // 오버레이 밖 클릭하면 핀 해제
      hoverOverlay.addEventListener("click", (e) => {
        e.stopPropagation();
      });
      window.addEventListener("click", () => {
        // 핀 상태에서 바깥 클릭 시 해제
        if(overlayPinned){
          overlayPinned = false;
          pinnedMarkerId = "";
          hideHoverOverlay(true);
        }
      });

      resetDimBtn.addEventListener("click", () => {
        state.ui.dimmedMarkerIds = [];
        saveState();
        draw();
      });

      // ===== Drawing =====
      function drawBackgroundGrid(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;
        ctx.save();
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = "#070b12";
        ctx.fillRect(0,0,w,h);
        ctx.globalAlpha = 0.10;
        ctx.strokeStyle = "#243447";
        for(let x=0; x<w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
        for(let y=0; y<h; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
        ctx.restore();
      }

      function drawArrow(ax, ay, bx, by){
        const dx = bx - ax;
        const dy = by - ay;
        const len = Math.hypot(dx, dy);
        if(len < 1e-6) return;

        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();

        const ux = dx / len;
        const uy = dy / len;
        const head = 10 / view.scale;
        const angle = Math.atan2(uy, ux);
        const a1 = angle + Math.PI * 0.85;
        const a2 = angle - Math.PI * 0.85;
        const hx1 = bx + Math.cos(a1) * head;
        const hy1 = by + Math.sin(a1) * head;
        const hx2 = bx + Math.cos(a2) * head;
        const hy2 = by + Math.sin(a2) * head;

        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(hx1, hy1);
        ctx.lineTo(hx2, hy2);
        ctx.closePath();
        ctx.fill();
      }

      function shrinkSegmentToCircles(ax, ay, arWorld, bx, by, brWorld){
        const dx = bx - ax;
        const dy = by - ay;
        const len = Math.hypot(dx, dy) || 1;
        const ux = dx / len;
        const uy = dy / len;
        const aShrink = Math.min(arWorld, len * 0.49);
        const bShrink = Math.min(brWorld, len * 0.49);
        const sx = ax + ux * aShrink;
        const sy = ay + uy * aShrink;
        const ex = bx - ux * bShrink;
        const ey = by - uy * bShrink;
        return { sx, sy, ex, ey };
      }

      function draw(){
        const rect = canvas.getBoundingClientRect();
        const w = rect.width, h = rect.height;

        drawBackgroundGrid();

        const numMap = buildNumberMap();
        const mp = currentMap();
        const dimSet = new Set(Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : []);

        ctx.save();
        ctx.translate(view.offsetX, view.offsetY);
        ctx.scale(view.scale, view.scale);

        if(mapImgReady){
          ctx.drawImage(mapImg, 0, 0, mp.width, mp.height);
        }else{
          ctx.fillStyle = "#0d131c";
          ctx.fillRect(0,0,mp.width, mp.height);
          ctx.strokeStyle = "#223042";
          ctx.lineWidth = 4 / view.scale;
          ctx.strokeRect(0,0,mp.width, mp.height);

          // 유저에게 힌트(모바일은 URL이 없으면 이미지가 안 나오는 것이 정상)
          ctx.save();
          ctx.fillStyle = "rgba(231,238,248,.82)";
          ctx.font = `${24 / view.scale}px system-ui`;
          ctx.fillText("지도 이미지가 없습니다.", 40 / view.scale, 80 / view.scale);
          ctx.font = `${14 / view.scale}px system-ui`;
          ctx.fillStyle = "rgba(159,176,198,.85)";
          ctx.fillText("관리자에서 페이지의 URL(지도 이미지 URL)을 설정하세요.", 40 / view.scale, 110 / view.scale);
          ctx.restore();
        }

        const visible = getVisibleMarkers();
        const visibleSet = new Set(visible.map(m => m.id));
        countInfo.textContent = `표시 중 마커: ${visible.length} / 페이지 전체: ${currentMarkers().length}`;

        // links
        ctx.save();
        ctx.strokeStyle = "#ffffff";
        ctx.fillStyle = "#ffffff";
        ctx.globalAlpha = 0.85;
        ctx.lineWidth = 2 / view.scale;

        for(const l of currentLinks()){
          if(!visibleSet.has(l.fromId) || !visibleSet.has(l.toId)) continue;

          const a = currentMarkers().find(m => m.id === l.fromId);
          const b = currentMarkers().find(m => m.id === l.toId);
          if(!a || !b) continue;

          const ax = a.x * mp.width, ay = a.y * mp.height;
          const bx = b.x * mp.width, by = b.y * mp.height;

          const arPx = (typeof a.radiusPx === "number" ? a.radiusPx : DEFAULT_MARKER_RADIUS_PX);
          const brPx = (typeof b.radiusPx === "number" ? b.radiusPx : DEFAULT_MARKER_RADIUS_PX);

          const arWorld = arPx / markerScaleDenom();
          const brWorld = brPx / markerScaleDenom();

          const seg = shrinkSegmentToCircles(ax, ay, arWorld, bx, by, brWorld);
          drawArrow(seg.sx, seg.sy, seg.ex, seg.ey);
        }
        ctx.restore();

        // markers
        for(const m of visible){
          const wx = m.x * mp.width;
          const wy = m.y * mp.height;

          const isSelected = (state.ui.selectedMarkerId === m.id);
          const color = getMarkerColor(m);

          const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
          const denom = markerScaleDenom();
          const r = radiusPx / denom;

          const isDimmed = dimSet.has(m.id);
          const alpha = isDimmed ? 0.30 : 1.0;

          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.translate(wx, wy);

          // circle
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(0,0,r,0,Math.PI*2);
          ctx.fill();

          // stroke
          ctx.lineWidth = (isSelected ? 4 : 2) / denom;
          ctx.strokeStyle = isSelected ? "#ffd43b" : "#0b0f14";
          ctx.stroke();

          // number
          const num = numMap.get(m.id);
          if(num != null){
            ctx.save();
            ctx.fillStyle = "#000000";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const fs = Math.max((radiusPx * 0.95) / denom, 9 / denom);
            ctx.font = `900 ${fs}px system-ui`;
            ctx.fillText(String(num), 0, 0);
            ctx.restore();
          }

          // label
          const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
          const weight = (typeof m.labelWeight === "number" ? m.labelWeight : DEFAULT_LABEL_WEIGHT);
          const lcolor = (typeof m.labelColor === "string" && /^#([0-9a-fA-F]{6})$/.test(m.labelColor)) ? m.labelColor : DEFAULT_LABEL_COLOR;

          ctx.fillStyle = lcolor;
          ctx.font = `${weight} ${sizePx / denom}px system-ui`;
          ctx.textBaseline = "middle";
          ctx.textAlign = "left";

          const gap = 10 / denom;
          ctx.fillText(getMarkerLabel(m), r + gap, 0);

          ctx.restore();
        }

        ctx.restore();
      }

      // ===== Init =====
      function rebuildFromState(){
        rebuildCategoryBar();
        renderSelectedPanel();
      }

      async function init(){
        // 로고 표시
        loadLogo();

        // index는 원하면 remote state.json을 우선 적용할 수 있음
        // (원치 않으면 주석처리 가능)
        // await tryFetchRemoteState();

        // 데이터 정규화(최소)
        for(const m of currentMarkers()){
          if(typeof m.title !== "string") m.title = "";
          if(typeof m.youtubeUrl !== "string") m.youtubeUrl = "";
          if(typeof m.youtubeLabel !== "string") m.youtubeLabel = "";
          if(typeof m.colorOverride !== "string") m.colorOverride = "";
          if(typeof m.category !== "string") m.category = currentCategories()[0]?.name || "default";
          if(typeof m.createdAt !== "string") m.createdAt = nowISO();
          if(typeof m.radiusPx !== "number" || !isFinite(m.radiusPx)) m.radiusPx = DEFAULT_MARKER_RADIUS_PX;
          if(typeof m.labelSizePx !== "number" || !isFinite(m.labelSizePx)) m.labelSizePx = calcLabelSizeFromRadius(m.radiusPx);
          if(typeof m.labelWeight !== "number" || !isFinite(m.labelWeight)) m.labelWeight = DEFAULT_LABEL_WEIGHT;
          if(typeof m.labelColor !== "string") m.labelColor = DEFAULT_LABEL_COLOR;
          if(typeof m.groupId !== "number" || !isFinite(m.groupId)) m.groupId = 0;
          if(typeof m.chainStart !== "boolean") m.chainStart = false;
          if(typeof m.memo !== "string") m.memo = "";
        }

        state.ui.selectedMarkerId = "";
        state.ui.selectedCategory = state.ui.selectedCategory || "";
        state.ui.dimmedMarkerIds = state.ui.dimmedMarkerIds || [];
        saveState();

        rebuildFromState();
        resizeCanvas();
        resetView();
        await loadMapImageForCurrentPage();
        draw();
      }

      init();
    })();
  </script>
</body>
</html>
