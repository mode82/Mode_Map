<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAPMODE (index)</title>

  <style>
    :root{
      color-scheme: dark;
      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.9);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    button, input, select, textarea{
      background: rgba(16,24,38,.65);
      border: 1px solid rgba(39,52,74,.9);
      color: var(--text);
      border-radius: var(--r14);
      padding:9px 11px;
      font-size:14px;
      outline:none;
      transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button{ cursor:pointer; font-weight:800; }
    button:hover{ border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 3px rgba(124,196,255,.12); }
    button:active{ transform: translateY(1px); }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(39,52,74,.9);
      border-radius:999px;
      background: rgba(14,22,38,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.6);
    }
    .muted{ color: var(--muted); font-size:12px; }
    .hr{ height:1px; background: rgba(31,42,58,.9); margin:12px 0; }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr 380px;
      height: calc(100vh - 56px);
    }
    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
    }
    .panel.left{ border-right:1px solid rgba(31,42,58,.85); }
    .panel.right{ border-left:1px solid rgba(31,42,58,.85); }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }
    .section h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color: rgba(231,238,248,.92);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .center{ position:relative; overflow:hidden; }
    #canvas{
      width:100%;
      height:100%;
      display:block;
      background:#0b0f14;

      /* ✅ iOS/모바일 기본 동작 차단 (패닝 이벤트 안정화) */
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none;

      /* ✅ 커서: 원래대로(손 모양/잡기 모양 금지) */
      cursor: default;
    }

    .catGrid{ display:flex; flex-wrap:wrap; gap:8px; }
    .catBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .catDot{
      width:10px; height:10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-block;
    }
    .catBtn.active{
      border-color: rgba(124,196,255,.9);
      box-shadow: 0 0 0 3px rgba(124,196,255,.14);
    }

    .pageBtn{
      width:100%;
      padding:12px 12px;
      border-radius: var(--r16);
      border: 2px solid rgba(124,196,255,.40);
      background: rgba(10,18,30,.45);
      box-shadow: 0 0 0 4px rgba(124,196,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      text-align:left;
    }
    .pageBtn:hover{ border-color: rgba(124,196,255,.75); box-shadow: 0 0 0 4px rgba(124,196,255,.12); }
    .pageBtn.active{ border-color: rgba(57,217,138,.85); box-shadow: 0 0 0 4px rgba(57,217,138,.12); }
    .pageBtn .name{
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .linkBox{
      padding:12px 12px;
      border:1px solid rgba(39,52,74,.9);
      border-radius: var(--r16);
      background: rgba(8,12,20,.55);
      word-break:break-all;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    .resetDanger{
      width:100%;
      border: 2px solid rgba(255,93,93,.92) !important;
      background: rgba(26,10,12,.45) !important;
      box-shadow: 0 0 0 4px rgba(255,93,93,.10);
    }

    #hoverOverlay{
      position:absolute;
      display:none;
      z-index:50;
      background: rgba(10,16,28,.78);
      border: 1px solid rgba(124,196,255,.18);
      border-radius: var(--r16);
      padding:10px 12px;
      max-width:min(420px, 84vw);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      pointer-events:auto;
    }
    #hoverOverlay .memoLabel{ font-size:12px; color: var(--muted); margin-bottom:6px; font-weight:800; }
    #hoverOverlay textarea{
      width:100%;
      resize:none;
      line-height:1.35;
      padding:10px 10px;
      border-radius:12px;
      margin-bottom:10px;
      font-size:13px;
    }
    #hoverOverlay textarea[readonly]{ opacity:.95; }
    #hoverOverlay .yt{ font-size:14px; font-weight:900; }

    @media (max-width:1100px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .panel.left{ border-right:none; border-bottom:1px solid rgba(31,42,58,.85); }
      .panel.right{ border-left:none; border-top:1px solid rgba(31,42,58,.85); }
      #canvas{ height:55vh; }
    }
  </style>
</head>

<body>
  <header>
    <div class="pill">
      <span class="badge">USER</span>
      <span class="muted">index</span>
    </div>
    <div class="pill" style="margin-left:10px;">
      <span class="muted">게임</span>
      <b id="gameTitleText">-</b>
    </div>
    <span class="pill" style="margin-left:auto;">
      <span class="muted" id="syncInfo">sync: -</span>
    </span>
  </header>

  <div class="wrap">
    <aside class="panel left">
      <div class="section">
        <h3>페이지 <span class="badge" id="pageBadge" style="margin-left:auto;">-</span></h3>
        <div id="pageList" style="display:flex; flex-direction:column; gap:10px;"></div>
      </div>
    </aside>

    <div class="center" id="centerStage">
      <canvas id="canvas"></canvas>

      <div id="hoverOverlay">
        <div class="memoLabel">메모</div>
        <textarea id="hoverMemo" rows="3" readonly></textarea>
        <div class="yt" id="hoverYt">-</div>
      </div>
    </div>

    <aside class="panel right">
      <div class="section">
        <h3>카테고리</h3>
        <div class="catGrid" id="categoryBar"></div>
        <div class="muted" id="countInfo" style="margin-top:10px;">-</div>
      </div>

      <div class="section">
        <button id="resetDimBtn" class="resetDanger">마커 초기화</button>
      </div>

      <div class="section">
        <h3 id="selectedHeader">선택한 마커</h3>
        <div class="hr"></div>
        <div class="muted">링크</div>
        <div id="youtubeBox" class="linkBox" style="margin-top:8px;">-</div>
      </div>
    </aside>
  </div>

  <script>
    // =============================
    // index 전용: state.json 경로 통일
    // =============================
    const REMOTE_STATE_URL = new URL("./data/state.json", location.href).toString();
    const REMOTE_SYNC_INTERVAL_MS = 12000;

    // local state key (프로젝트 기존 키 유지)
    const LS_KEY = "imgmap_multi_v700";

    // helpers
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const safeParse = (s,f)=>{ try{return JSON.parse(s);}catch{return f;} };
    const escapeHtml = (s)=>String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    const isValidUrl = (u)=>{ try{ new URL(u, location.href); return true; }catch{ return false; } };
    const nowISO = ()=> new Date().toISOString();

    // =============================
    // state
    // =============================
    const defaultState = {
      ui:{ admin:false, selectedCategory:"", selectedMarkerId:"", dimmedMarkerIds:[] },
      currentGameId:"",
      currentPageId:"",
      games:[],
      _updatedAt: 0,
      _updatedAtISO: ""
    };

    const state = (() => {
      const loaded = safeParse(localStorage.getItem(LS_KEY)||"", null);
      if(loaded && Array.isArray(loaded.games)) {
        loaded.ui = loaded.ui || {};
        loaded.ui.admin = false; // index 강제
        loaded.ui.dimmedMarkerIds = Array.isArray(loaded.ui.dimmedMarkerIds) ? loaded.ui.dimmedMarkerIds : [];
        return loaded;
      }
      return structuredClone(defaultState);
    })();

    function saveState(){
      state._updatedAt = Date.now();
      state._updatedAtISO = nowISO();
      try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){ console.warn(e); }
    }

    function getGameById(id){ return (state.games||[]).find(g=>g.id===id) || null; }
    function getCurrentGame(){
      if(!Array.isArray(state.games) || state.games.length===0) return null;
      if(!state.currentGameId) state.currentGameId = state.games[0].id;
      return getGameById(state.currentGameId) || state.games[0];
    }
    function getPageById(game, pid){ return (game.pages||[]).find(p=>p.id===pid) || null; }
    function getCurrentPage(){
      const g = getCurrentGame();
      if(!g) return null;
      if(!state.currentPageId) state.currentPageId = g.pages?.[0]?.id || "";
      return getPageById(g, state.currentPageId) || g.pages?.[0] || null;
    }
    function currentCategories(){ return getCurrentGame()?.categories || []; }
    function currentMarkers(){ return getCurrentPage()?.markers || []; }
    function currentLinks(){ return getCurrentPage()?.links || []; }
    function currentMap(){ return getCurrentPage()?.map || null; }

    function getCategoryColor(name){
      const c = currentCategories().find(x=>x.name===name);
      return c?.color || "#e6edf3";
    }
    function getMarkerColor(m){
      const ov = (m.colorOverride||m.color||"").toString().trim();
      return ov ? ov : getCategoryColor(m.category);
    }

    // =============================
    // DOM
    // =============================
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { alpha:true });

    const centerStage = document.getElementById("centerStage");
    const gameTitleText = document.getElementById("gameTitleText");
    const pageBadge = document.getElementById("pageBadge");
    const pageList = document.getElementById("pageList");
    const categoryBar = document.getElementById("categoryBar");
    const countInfo = document.getElementById("countInfo");
    const selectedHeader = document.getElementById("selectedHeader");
    const youtubeBox = document.getElementById("youtubeBox");
    const resetDimBtn = document.getElementById("resetDimBtn");
    const syncInfo = document.getElementById("syncInfo");

    const hoverOverlay = document.getElementById("hoverOverlay");
    const hoverMemo = document.getElementById("hoverMemo");
    const hoverYt = document.getElementById("hoverYt");

    // =============================
    // view (해상도 + 패닝)
    // =============================
    const view = { scale:1, minScale:0.03, maxScale:16, offsetX:0, offsetY:0 };
    const DEFAULT_MARKER_RADIUS_PX = 12; // 원래 굵기/가독성 위해 기본값 약간 상향
    const PAN_MARGIN_PX = 220; // ✅ "고정처럼 보이는" 문제를 막는 여유 마진

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // CSS 크기 기준으로 실제 버퍼를 DPR로 확장
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));

      // 이후 모든 draw는 CSS px 좌표로
      ctx.setTransform(dpr,0,0,dpr,0,0);

      // 고품질 스무딩
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      clampViewToBounds();
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    function clampViewToBounds(){
      const rect = canvas.getBoundingClientRect();
      const cw = rect.width, ch = rect.height;
      const mp = currentMap();
      if(!mp) return;

      const mw = (mp.width||1) * view.scale;
      const mh = (mp.height||1) * view.scale;

      // ✅ “완전 고정”이 아니라 마진 내에서 움직이게 허용
      const margin = PAN_MARGIN_PX;

      if(mw <= cw){
        const centerX = (cw - mw) / 2;
        view.offsetX = clamp(view.offsetX, centerX - margin, centerX + margin);
      } else {
        view.offsetX = clamp(view.offsetX, cw - mw - margin, margin);
      }

      if(mh <= ch){
        const centerY = (ch - mh) / 2;
        view.offsetY = clamp(view.offsetY, centerY - margin, centerY + margin);
      } else {
        view.offsetY = clamp(view.offsetY, ch - mh - margin, margin);
      }
    }

    function resetView(){
      const mp = currentMap();
      if(!mp) return;
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const s = Math.min(w / (mp.width||1), h / (mp.height||1)) * 0.95;
      view.scale = clamp(s, view.minScale, view.maxScale);
      view.offsetX = (w - (mp.width||1) * view.scale) / 2;
      view.offsetY = (h - (mp.height||1) * view.scale) / 2;
      clampViewToBounds();
    }

    function worldToScreen(wx, wy){ return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY }; }
    function screenToWorld(sx, sy){ return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale }; }

    // =============================
    // map image
    // =============================
    const mapImg = new Image();
    mapImg.crossOrigin = "anonymous";
    let mapImgReady = false;

    async function loadMapImageForCurrentPage(){
      const mp = currentMap();
      mapImgReady = false;
      if(!mp){
        draw();
        return;
      }
      let url = (mp.imageUrl||mp.url||"").toString().trim();
      if(!url){
        draw();
        return;
      }
      const abs = new URL(url, location.href).toString();
      mapImg.onload = () => {
        mapImgReady = true;
        mp.width = mp.width || mapImg.naturalWidth || mapImg.width || 1;
        mp.height = mp.height || mapImg.naturalHeight || mapImg.height || 1;
        resetView();
        draw();
      };
      mapImg.onerror = () => {
        mapImgReady = false;
        draw();
      };

      // 캐시 무시(해상도/갱신 문제 방지)
      mapImg.src = abs + (abs.includes("?") ? "&" : "?") + "v=" + Date.now();
    }

    // =============================
    // UI build
    // =============================
    function rebuildCategoryBar(){
      categoryBar.innerHTML = "";
      categoryBar.appendChild(makeCatButton("전체","", "#223042"));
      for(const c of currentCategories()){
        categoryBar.appendChild(makeCatButton(c.name, c.name, c.color || "#e6edf3"));
      }
    }
    function makeCatButton(label, value, color){
      const btn = document.createElement("button");
      btn.className = "catBtn" + (state.ui.selectedCategory===value ? " active" : "");
      const dot = document.createElement("span");
      dot.className="catDot";
      dot.style.background = color;
      btn.appendChild(dot);
      const t = document.createElement("span");
      t.textContent = label;
      btn.appendChild(t);

      btn.addEventListener("click", ()=>{
        state.ui.selectedCategory = value;
        saveState();
        rebuildCategoryBar();
        draw();
      });
      return btn;
    }

    function rebuildPageList(){
      const g = getCurrentGame();
      const p = getCurrentPage();
      pageList.innerHTML = "";
      if(!g || !p){
        pageBadge.textContent = "state 없음";
        gameTitleText.textContent = "-";
        return;
      }

      gameTitleText.textContent = g.name || "Map Demo";
      pageBadge.textContent = `${g.name} / ${p.name}`;

      for(const pg of (g.pages||[])){
        const btn = document.createElement("button");
        btn.className = "pageBtn" + (pg.id===p.id ? " active" : "");
        btn.innerHTML = `<div class="name">${escapeHtml(pg.name||"Page")}</div>`;
        btn.addEventListener("click", ()=>{
          state.currentPageId = pg.id;
          state.ui.selectedMarkerId = "";
          state.ui.dimmedMarkerIds = [];
          saveState();
          rebuildPageList();
          rebuildCategoryBar();
          loadMapImageForCurrentPage();
          draw();
        });
        pageList.appendChild(btn);
      }
    }

    function renderSelectedPanel(){
      const m = currentMarkers().find(x=>x.id===state.ui.selectedMarkerId);
      if(!m){
        selectedHeader.textContent = "선택한 마커";
        youtubeBox.textContent = "-";
        return;
      }
      const name = (m.title||m.name||"").toString().trim() || "(이름 없음)";
      selectedHeader.textContent = `선택한 마커: ${name}`;

      const url = (m.youtubeUrl||m.url||"").toString().trim();
      const display = (m.youtubeLabel||m.title||m.name||"유튜브").toString().trim();
      if(url && isValidUrl(url)){
        youtubeBox.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(display)}</a>`;
      }else{
        youtubeBox.textContent = display || "-";
      }
    }

    // =============================
    // marker numbering (✅ 숫자 복구)
    // =============================
    function getMarkerNumber(m, fallbackIndex){
      const cand =
        m.n ?? m.no ?? m.num ?? m.number ?? m.order ?? m.idx ?? m.index;
      if(Number.isFinite(Number(cand))) return String(Number(cand));

      // id가 "m12" / "12" 이런 형태면 숫자 추출
      const id = (m.id ?? "").toString();
      const match = id.match(/(\d+)/);
      if(match) return match[1];

      return String(fallbackIndex + 1);
    }

    // =============================
    // hit test
    // =============================
    function getPointerPos(evt){
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }
    function markerWorldPos(m){
      const mp = currentMap();
      return { wx: (m.x||0) * (mp?.width||1), wy: (m.y||0) * (mp?.height||1) };
    }
    function findMarkerAtScreen(sx, sy, visibleMarkers){
      const mp = currentMap();
      if(!mp) return null;

      for(let i=visibleMarkers.length-1;i>=0;i--){
        const m = visibleMarkers[i];
        const { wx, wy } = markerWorldPos(m);
        const p = worldToScreen(wx, wy);
        const baseR = (typeof m.radiusPx==="number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
        const r = baseR * view.scale;
        const dx = sx - p.x, dy = sy - p.y;
        if(dx*dx + dy*dy <= r*r) return m;
      }
      return null;
    }

    // =============================
    // overlay
    // =============================
    let overlayPinned = false;
    function hideHoverOverlay(force=false){
      if(!force && overlayPinned) return;
      hoverOverlay.style.display = "none";
    }
    function showOverlayForMarker(m, clientX, clientY, pinned=false){
      overlayPinned = pinned;
      hoverMemo.value = (m.memo||"").toString();

      const url = (m.youtubeUrl||m.url||"").toString().trim();
      const label = (m.youtubeLabel||m.title||m.name||"유튜브").toString().trim();
      if(url && isValidUrl(url)){
        hoverYt.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(label)}</a>`;
      }else{
        hoverYt.innerHTML = `<span class="muted">유튜브 없음</span>`;
      }

      const stageRect = centerStage.getBoundingClientRect();
      let x = clientX - stageRect.left + 16;
      let y = clientY - stageRect.top + 16;
      hoverOverlay.style.left = x + "px";
      hoverOverlay.style.top = y + "px";
      hoverOverlay.style.display = "block";

      const pad=10;
      const r = hoverOverlay.getBoundingClientRect();
      const maxX = stageRect.width - r.width - pad;
      const maxY = stageRect.height - r.height - pad;
      x = clamp(x, pad, Math.max(pad, maxX));
      y = clamp(y, pad, Math.max(pad, maxY));
      hoverOverlay.style.left = x + "px";
      hoverOverlay.style.top = y + "px";
    }

    // =============================
    // zoom
    // =============================
    canvas.addEventListener("wheel", (evt)=>{
      evt.preventDefault();
      const mp = currentMap();
      if(!mp) return;

      const { x:sx, y:sy } = getPointerPos(evt);
      const before = screenToWorld(sx, sy);

      const zoomFactor = Math.exp((-evt.deltaY) * 0.0015);
      view.scale = clamp(view.scale * zoomFactor, view.minScale, view.maxScale);

      const after = screenToWorld(sx, sy);
      view.offsetX += (after.x - before.x) * view.scale;
      view.offsetY += (after.y - before.y) * view.scale;

      clampViewToBounds();
      draw();
    }, { passive:false });

    // =============================
    // ✅ 좌클릭 드래그 패닝 (확실히 동작)
    // =============================
    let dragActive = false;
    let dragMoved = false;
    let downScreen = {x:0,y:0};
    let viewStart = {ox:0, oy:0};
    let downMarkerId = "";
    const DRAG_THRESHOLD = 3;

    canvas.addEventListener("pointerdown", (evt)=>{
      if(evt.button !== 0) return; // 좌클릭만
      evt.preventDefault();

      // ✅ 핵심: 캔버스가 드래그 이벤트를 끝까지 붙잡는다
      canvas.setPointerCapture(evt.pointerId);

      const {x:sx,y:sy} = getPointerPos(evt);
      dragActive = true;
      dragMoved = false;
      downScreen = {x:sx,y:sy};
      viewStart = {ox:view.offsetX, oy:view.offsetY};

      // 현재 보이는 마커 리스트 준비
      const cat = state.ui.selectedCategory || "";
      const visibleMarkers = cat ? currentMarkers().filter(mm=>mm.category===cat) : currentMarkers();
      const m = findMarkerAtScreen(sx, sy, visibleMarkers);
      downMarkerId = m ? m.id : "";

      if(m){
        state.ui.selectedMarkerId = m.id;
        renderSelectedPanel();
      }
    });

    canvas.addEventListener("pointermove", (evt)=>{
      if(!dragActive){
        if(!overlayPinned){
          const cat = state.ui.selectedCategory || "";
          const visibleMarkers = cat ? currentMarkers().filter(mm=>mm.category===cat) : currentMarkers();
          const {x:sx,y:sy} = getPointerPos(evt);
          const m = findMarkerAtScreen(sx, sy, visibleMarkers);
          if(m) showOverlayForMarker(m, evt.clientX, evt.clientY, false);
          else hideHoverOverlay();
        }
        return;
      }

      evt.preventDefault();
      const {x:sx,y:sy} = getPointerPos(evt);
      const dx = sx - downScreen.x;
      const dy = sy - downScreen.y;

      if(!dragMoved && (Math.abs(dx)>DRAG_THRESHOLD || Math.abs(dy)>DRAG_THRESHOLD)){
        dragMoved = true;
        if(!overlayPinned) hideHoverOverlay(true);
      }

      // ✅ 패닝은 항상 수행
      view.offsetX = viewStart.ox + dx;
      view.offsetY = viewStart.oy + dy;
      clampViewToBounds();
      draw();
    });

    function endDrag(){
      dragActive = false;
      dragMoved = false;
      downMarkerId = "";
    }

    canvas.addEventListener("pointerup", (evt)=>{
      if(!dragActive) return;
      evt.preventDefault();

      // 클릭(드래그X)일 때만 불투명 토글
      if(!dragMoved && downMarkerId){
        const arr = Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : [];
        const idx = arr.indexOf(downMarkerId);
        if(idx>=0) arr.splice(idx,1);
        else arr.push(downMarkerId);
        state.ui.dimmedMarkerIds = arr;
        saveState();
        draw();
      }
      endDrag();
    });

    canvas.addEventListener("pointercancel", endDrag);
    canvas.addEventListener("lostpointercapture", endDrag);

    // 클릭으로 오버레이 고정/해제
    canvas.addEventListener("click", (evt)=>{
      if(dragActive || dragMoved) return;

      const cat = state.ui.selectedCategory || "";
      const visibleMarkers = cat ? currentMarkers().filter(mm=>mm.category===cat) : currentMarkers();
      const {x:sx,y:sy} = getPointerPos(evt);
      const m = findMarkerAtScreen(sx, sy, visibleMarkers);
      if(m){
        showOverlayForMarker(m, evt.clientX, evt.clientY, true);
      }else{
        overlayPinned = false;
        hideHoverOverlay(true);
      }
    });

    // reset dim
    resetDimBtn.addEventListener("click", ()=>{
      state.ui.dimmedMarkerIds = [];
      saveState();
      draw();
    });

    // =============================
    // ✅ 링크(선) 렌더러: 다양한 포맷 지원 (사라지지 않게)
    // =============================
    function buildMarkerMap(){
      const mp = currentMap();
      const markers = currentMarkers();
      const map = new Map();
      for(let i=0;i<markers.length;i++){
        const m = markers[i];
        map.set(m.id, m);
        // 일부 구현에서 숫자키로 참조하는 경우 대비
        const n = getMarkerNumber(m,i);
        map.set(n, m);
      }
      // id가 없는 경우 대비: index 키도 넣음
      for(let i=0;i<markers.length;i++){
        map.set(String(i), markers[i]);
      }
      return { mp, markers, idMap: map };
    }

    function normalizePointToWorld(pt, mp){
      // pt가 {x,y} 형태일 때
      const x = Number(pt?.x);
      const y = Number(pt?.y);
      if(!Number.isFinite(x) || !Number.isFinite(y)) return null;

      // 0~1 정규화면 mp 크기로 환산, 아니면 절대좌표로 취급
      const isNorm = (Math.abs(x) <= 1.000001 && Math.abs(y) <= 1.000001);
      return isNorm ? { wx: x * mp.width, wy: y * mp.height } : { wx: x, wy: y };
    }

    function extractLinkSegments(pageLinks, mp, idMap){
      const segments = [];

      for(const ln of (pageLinks||[])){
        if(!ln) continue;

        // 1) ID 기반
        const aKey = ln.a ?? ln.from ?? ln.src ?? ln.start ?? ln.s;
        const bKey = ln.b ?? ln.to ?? ln.dst ?? ln.end ?? ln.t;
        if(aKey != null && bKey != null){
          const a = idMap.get(String(aKey)) || idMap.get(aKey);
          const b = idMap.get(String(bKey)) || idMap.get(bKey);
          if(a && b){
            const ax = (a.x||0) * mp.width, ay = (a.y||0) * mp.height;
            const bx = (b.x||0) * mp.width, by = (b.y||0) * mp.height;
            segments.push([{wx:ax, wy:ay}, {wx:bx, wy:by}]);
            continue;
          }
        }

        // 2) points/pts/path 기반 (폴리라인)
        const pts = ln.points || ln.pts || ln.path || ln.polyline || null;
        if(Array.isArray(pts) && pts.length >= 2){
          const wpts = [];
          for(const p of pts){
            const w = normalizePointToWorld(p, mp);
            if(w) wpts.push(w);
          }
          if(wpts.length >= 2){
            segments.push(wpts);
            continue;
          }
        }

        // 3) 좌표쌍 직접
        const ax = ln.ax ?? ln.x1 ?? ln.xa;
        const ay = ln.ay ?? ln.y1 ?? ln.ya;
        const bx = ln.bx ?? ln.x2 ?? ln.xb;
        const by = ln.by ?? ln.y2 ?? ln.yb;
        if([ax,ay,bx,by].every(v=>Number.isFinite(Number(v)))){
          const p1 = normalizePointToWorld({x:Number(ax), y:Number(ay)}, mp);
          const p2 = normalizePointToWorld({x:Number(bx), y:Number(by)}, mp);
          if(p1 && p2){
            segments.push([p1,p2]);
            continue;
          }
        }
      }

      return segments;
    }

    // =============================
    // draw
    // =============================
    function drawBackground(){
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);
      ctx.fillStyle = "#070b12";
      ctx.fillRect(0,0,rect.width,rect.height);
    }

    function draw(){
      const mp = currentMap();
      drawBackground();

      if(!mp){
        countInfo.textContent = "state.json을 불러오지 못했거나 페이지가 없습니다.";
        return;
      }

      // ===== 지도 + 오브젝트는 월드좌표로 렌더링 =====
      ctx.save();
      ctx.translate(view.offsetX, view.offsetY);
      ctx.scale(view.scale, view.scale);

      // 지도 이미지
      if(mapImgReady){
        ctx.drawImage(mapImg, 0, 0, mp.width, mp.height);
      }else{
        ctx.fillStyle = "#0d131c";
        ctx.fillRect(0,0,mp.width, mp.height);
      }

      // 현재 카테고리 필터(마커만)
      const cat = state.ui.selectedCategory || "";
      const allMarkers = currentMarkers();
      const visibleMarkers = cat ? allMarkers.filter(mm=>mm.category===cat) : allMarkers;

      // ===== ✅ 선(링크): 필터와 무관하게 "항상" 그림 =====
      const { idMap } = buildMarkerMap();
      const links = currentLinks();
      const segs = extractLinkSegments(links, mp, idMap);

      // 링크가 비어있을 때도, “혹시 마커에 next/prev 방식”이 있으면 연결 (보정)
      // (원본 구조를 모르는 상태에서 최대한 복구용)
      if(segs.length === 0){
        // 예: m.nextId / m.toId 같은 필드가 있으면 연결
        for(const m of allMarkers){
          const k = m.nextId ?? m.toId ?? m.linkTo ?? null;
          if(k==null) continue;
          const b = idMap.get(String(k)) || idMap.get(k);
          if(!b) continue;
          const ax = (m.x||0) * mp.width, ay = (m.y||0) * mp.height;
          const bx = (b.x||0) * mp.width, by = (b.y||0) * mp.height;
          segs.push([{wx:ax, wy:ay},{wx:bx, wy:by}]);
        }
      }

      // 링크 스타일(원래 느낌 유지: 얇지 않게)
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.strokeStyle = "rgba(124,196,255,.75)";
      ctx.lineWidth = 3 / view.scale;     // 월드에서 두께 일정하게 보이도록
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      for(const poly of segs){
        if(!poly || poly.length < 2) continue;
        ctx.beginPath();
        ctx.moveTo(poly[0].wx, poly[0].wy);
        for(let i=1;i<poly.length;i++){
          ctx.lineTo(poly[i].wx, poly[i].wy);
        }
        ctx.stroke();
      }
      ctx.restore();

      // ===== ✅ 마커: 원 + 숫자(중앙) + 텍스트 =====
      const dimSet = new Set(Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : []);

      for(let i=0;i<visibleMarkers.length;i++){
        const m = visibleMarkers[i];
        const wx = (m.x||0) * mp.width;
        const wy = (m.y||0) * mp.height;

        const baseR = (typeof m.radiusPx==="number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
        const r = baseR; // 월드 스케일 적용 전(현재 ctx가 scale됨)

        const isDim = dimSet.has(m.id);
        const alpha = isDim ? 0.30 : 1.0;

        const fill = getMarkerColor(m);

        // 원
        ctx.save();
        ctx.translate(wx, wy);
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.fillStyle = fill;
        ctx.arc(0,0,r,0,Math.PI*2);
        ctx.fill();

        // 테두리(원래 두께 느낌)
        ctx.strokeStyle = "rgba(0,0,0,.70)";
        ctx.lineWidth = 3;
        ctx.stroke();

        // 숫자(원 중앙)
        ctx.globalAlpha = 1.0;
        const num = getMarkerNumber(m, i);
        const numSize = (m.numSizePx ? Number(m.numSizePx) : 14);
        ctx.font = `900 ${numSize}px system-ui`;
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(num, 0, 0);

        // 라벨(오른쪽)
        const label = (m.label ?? m.title ?? m.name ?? "").toString().trim();
        if(label){
          const labelSize = (m.labelSizePx ? Number(m.labelSizePx) : 16);
          ctx.font = `900 ${labelSize}px system-ui`;
          ctx.fillStyle = "rgba(231,238,248,.98)";
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          ctx.fillText(label, r + 10, 0);
        }

        ctx.restore();
      }

      ctx.restore();

      // 패널 정보
      countInfo.textContent = `마커(표시/전체): ${visibleMarkers.length}/${allMarkers.length} · 링크: ${segs.length}`;
      renderSelectedPanel();
    }

    // =============================
    // remote sync (state.json)
    // =============================
    async function tryFetchRemoteState(){
      try{
        const url = REMOTE_STATE_URL + (REMOTE_STATE_URL.includes("?") ? "&" : "?") + "v=" + Date.now();
        const res = await fetch(url, { cache:"no-store" });
        if(!res.ok) return null;
        const j = await res.json();
        if(!j || !Array.isArray(j.games)) return null;
        return j;
      }catch{
        return null;
      }
    }

    function acceptRemoteState(remote){
      remote.ui = remote.ui || {};
      remote.ui.admin = false; // index 강제

      // dim은 로컬 유지
      const keepDim = Array.isArray(state.ui?.dimmedMarkerIds) ? [...state.ui.dimmedMarkerIds] : [];

      state.games = remote.games;
      state.currentGameId = remote.currentGameId || state.games[0]?.id || "";

      const g = getCurrentGame();
      state.currentPageId = remote.currentPageId || g?.pages?.[0]?.id || "";

      state.ui.selectedCategory = state.ui.selectedCategory || "";
      state.ui.selectedMarkerId = "";
      state.ui.dimmedMarkerIds = keepDim;

      state._updatedAt = Number(remote._updatedAt || Date.now());
      state._updatedAtISO = remote._updatedAtISO || nowISO();

      saveState();
    }

    async function syncFromRemoteIfNewer(){
      const remote = await tryFetchRemoteState();
      if(!remote){
        syncInfo.textContent = "sync: offline";
        return;
      }

      const remoteAt = Number(remote._updatedAt || 0);
      const localAt = Number(state._updatedAt || 0);

      // remote가 더 최신이면 반영
      if(remoteAt && remoteAt > localAt){
        acceptRemoteState(remote);
        rebuildPageList();
        rebuildCategoryBar();
        await loadMapImageForCurrentPage();
        draw();
        syncInfo.textContent = "sync: updated";
      }else{
        syncInfo.textContent = "sync: ok";
      }
    }

    // =============================
    // init
    // =============================
    async function init(){
      resizeCanvas();

      rebuildPageList();
      rebuildCategoryBar();

      await loadMapImageForCurrentPage();
      resetView();
      draw();

      // 최초 1회 sync 후 반복
      await syncFromRemoteIfNewer();
      setInterval(syncFromRemoteIfNewer, REMOTE_SYNC_INTERVAL_MS);

      document.addEventListener("visibilitychange", ()=>{
        if(document.visibilityState==="visible") syncFromRemoteIfNewer();
      });
    }
    init();
  </script>
</body>
</html>
