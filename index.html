<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Interactive Multi-Map Demo v7.0.0</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      /* ✅ 상단 카테고리 슬롯(1~4) 폭 */
      --topSlotW: 150px;
      --topSlotH: 38px;
    }

    *{ box-sizing:border-box; }

    /* ✅ (1) 새로고침 순간 “초기 데모”가 잠깐 보이는 현상 방지: init 완료 전까지 숨김 */
    html:not(.ready) body{ visibility:hidden; }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.9);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    button, input, select, textarea{
      background: rgba(16,24,38,.65);
      border: 1px solid rgba(39,52,74,.9);
      color: var(--text);
      border-radius: var(--r14);
      padding:9px 11px;
      font-size:14px;
      outline:none;
      transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button{ cursor:pointer; font-weight:800; }
    button:hover{
      border-color: rgba(124,196,255,.55);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; box-shadow:none; }
    input:focus, select:focus, textarea:focus, button:focus-visible{
      border-color: rgba(124,196,255,.8);
      box-shadow: 0 0 0 4px rgba(124,196,255,.14);
    }

    .ghost{ background: rgba(9,14,24,.55); }
    .ok{ border-color: rgba(57,217,138,.65) !important; background: rgba(10,22,16,.55) !important; }
    .danger{ border-color: rgba(255,93,93,.55) !important; background: rgba(26,10,12,.55) !important; }
    .warn{ border-color: rgba(255,214,10,.55) !important; background: rgba(22,18,10,.55) !important; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(39,52,74,.9);
      border-radius:999px;
      background: rgba(14,22,38,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.6);
    }
    .badge.ok{ border-color: rgba(57,217,138,.6); background: rgba(10,22,16,.55); }
    .muted{ color: var(--muted); font-size:12px; }
    .k{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
    }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr 380px;
      height: calc(100vh - 56px);
    }
    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
    }
    .panel.left{ border-right:1px solid rgba(31,42,58,.85); }
    .panel.right{ border-left:1px solid rgba(31,42,58,.85); }
    .center{ position:relative; overflow:hidden; }
    #canvas{ width:100%; height:100%; display:block; background:#0b0f14; }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }
    .section h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color: rgba(231,238,248,.92);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .row{ display:flex; gap:8px; margin:8px 0; }
    .row > *{ flex:1; }
    .hr{ height:1px; background: rgba(31,42,58,.9); margin:12px 0; }
    .catGrid{ display:flex; flex-wrap:wrap; gap:8px; }
    .catBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .catDot{
      width:10px;
      height:10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-block;
    }
    .catBtn.active{
      border-color: rgba(124,196,255,.9);
      box-shadow: 0 0 0 3px rgba(124,196,255,.14);
    }

    .smallBtn{ padding:9px 11px; font-size:13px; }
    .linkBox{
      padding:12px 12px;
      border:1px solid rgba(39,52,74,.9);
      border-radius: var(--r16);
      background: rgba(8,12,20,.55);
      word-break:break-all;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    /* Hover overlay (user mode) */
    #hoverOverlay{
      position:absolute;
      display:none;
      z-index:50;
      background: rgba(10,16,28,.78);
      border: 1px solid rgba(124,196,255,.18);
      border-radius: var(--r16);
      padding:10px 12px;
      max-width:min(420px, 84vw);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      pointer-events:auto;
    }
    #hoverOverlay .memoLabel{
      font-size:12px;
      color: var(--muted);
      margin-bottom:6px;
      font-weight:800;
      letter-spacing:.2px;
    }
    #hoverOverlay textarea{
      width: 100%;
      resize:none;
      line-height:1.35;
      padding:10px 10px;
      border-radius:12px;
      margin-bottom:10px;
      font-size:13px;
    }
    #hoverOverlay textarea[readonly]{ opacity: .95; }
    #hoverOverlay .yt{ font-size:14px; font-weight:900; letter-spacing:.2px; }
    #hoverOverlay .yt a{ color: rgba(231,238,248,.95); text-decoration:none; }
    #hoverOverlay .yt a:hover{ text-decoration: underline; }

    @media (max-width: 1100px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .panel.left{ border-right:none; border-bottom:1px solid rgba(31,42,58,.85); }
      .panel.right{ border-left:none; border-top:1px solid rgba(31,42,58,.85); }
      #canvas{ height: 55vh; }
    }

    /* Reset button */
    .resetDanger{
      border: 2px solid rgba(255,93,93,.92) !important;
      background: rgba(26,10,12,.45) !important;
      box-shadow: 0 0 0 4px rgba(255,93,93,.10);
    }

    /* Page buttons */
    .pageBtn{
      width:100%;
      padding:12px 12px;
      border-radius: var(--r16);
      border: 2px solid rgba(124,196,255,.40);
      background: rgba(10,18,30,.45);
      box-shadow: 0 0 0 4px rgba(124,196,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      text-align:left;
    }
    .pageBtn:hover{
      border-color: rgba(124,196,255,.75);
      box-shadow: 0 0 0 4px rgba(124,196,255,.12);
    }
    .pageBtn.active{
      border-color: rgba(57,217,138,.85);
      box-shadow: 0 0 0 4px rgba(57,217,138,.12);
    }
    .pageBtn .name{
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* Title dropdown */
    .titleWrap{ position:relative; }
    .titleBtn{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      letter-spacing:.2px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      cursor:pointer;
      user-select:none;
      width: 100%;
      justify-content: space-between;
    }
    .titleBtn:hover{
      border-color: rgba(124,196,255,.55);
      box-shadow: 0 0 0 3px rgba(124,196,255,.12);
    }
    .titleBtn .caret{ opacity:.8; }
    .drop{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      width: min(420px, 72vw);
      background: rgba(10,16,28,.90);
      border:1px solid rgba(39,52,74,.95);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      padding:10px;
      display:none;
      z-index:999;
    }
    .drop .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(39,52,74,.75);
      background: rgba(8,12,20,.35);
      margin-bottom:8px;
    }
    .drop .item:last-child{ margin-bottom:0; }
    .drop .item .left{ min-width:0; }
    .drop .item .gname{
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .drop .item .gmeta{ font-size:12px; color: var(--muted); margin-top:4px; }

    /* ==========================================================
      ✅ 상단 카테고리 1~4 슬롯 UI
    ========================================================== */
    .topSlots{ display:flex; align-items:center; gap:10px; }
    .topSlot{
      width: var(--topSlotW);
      height: var(--topSlotH);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      overflow:hidden;
      position:relative;
      flex: 0 0 auto;
    }
    .topSlot.placeholder{ opacity: 0; pointer-events: none; }

    /* 카테고리1 = 로고 자리 */
    #logoSlot{ padding: 0; justify-content: center; border: 0 !important; background: transparent !important; }
    #logoImg{ width:100%; height:100%; object-fit: contain; display:none; padding:4px; }
  </style>
</head>

<body>
<header>
  <!-- ✅ 카테고리 1~4 슬롯 (총 4칸) -->
  <div class="topSlots" id="topSlots">
    <!-- 카테고리1: 로고 자리 -->
    <div class="topSlot" id="logoSlot" title="로고">
      <img id="logoImg" alt="logo" />
    </div>

    <!-- 카테고리2: 현재 게임 -->
    <div class="topSlot" id="cat2Slot" title="카테고리2 (현재 게임)">
      <div class="titleWrap" id="titleWrap" style="width:100%; height:100%;">
        <div class="titleBtn" id="gameTitleBtn" title="클릭해서 게임 목록" style="height:100%;">
          <span id="gameTitleText" style="min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">Map Demo</span>
          <span class="muted caret">▾</span>
        </div>
        <div class="drop" id="gameDrop"></div>
      </div>
    </div>

    <!-- 카테고리3: 자리만 확보 (보이지 않게) -->
    <div class="topSlot placeholder" id="cat3Slot" aria-hidden="true"></div>

    <!-- 카테고리4: 자리만 확보 (보이지 않게) -->
    <div class="topSlot placeholder" id="cat4Slot" aria-hidden="true"></div>
  </div>
</header>

<div class="wrap">
  <!-- 좌측: 페이지 -->
  <aside class="panel left">
    <div class="section">
      <h3> 페이지 <span class="badge" id="pageBadge" style="margin-left:auto;">-</span> </h3>
      <div id="pageList" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
  </aside>

  <div class="center" id="centerStage">
    <canvas id="canvas"></canvas>

    <!-- 유저모드: 텍스트에 hover/click 했을 때만 표시 -->
    <div id="hoverOverlay">
      <div class="memoLabel">메모</div>
      <textarea id="hoverMemo" cols="10" rows="3" placeholder="" readonly></textarea>
      <div class="yt" id="hoverYt">-</div>
    </div>
  </div>

  <!-- 우측 -->
  <aside class="panel right">
    <div class="section" id="categorySection">
      <h3>카테고리</h3>
      <div class="catGrid" id="categoryBar"></div>
      <div class="muted" id="countInfo" style="margin-top:10px;">-</div>
    </div>

    <!-- 유저모드: 마커 초기화 -->
    <div class="section" id="userResetSection">
      <button id="resetDimBtn" class="smallBtn resetDanger" style="width:100%;">마커 초기화</button>
    </div>

    <div class="section" id="selectedSection">
      <h3 id="selectedHeader">선택한 마커</h3>
      <div class="hr"></div>
      <div class="muted">링크</div>
      <div id="youtubeBox" class="linkBox" style="margin-top:8px;">-</div>
    </div>
  </aside>
</div>

<!-- ✅ iOS 폴리필: structuredClone 없으면 흰 화면 방지 -->
<script>
  if (typeof structuredClone !== "function") {
    window.structuredClone = (obj) => JSON.parse(JSON.stringify(obj));
  }
</script>

<script>
(() => {
  // ==========================================================
  // User-only (index) mode
  // ==========================================================
  const IS_ADMIN_PAGE = false;
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  // (기존 동작 유지) 모바일에서는 마커도 줌 비율에 맞춰 같이 스케일
  const IS_COARSE_POINTER = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
  const SCALE_MARKERS_WITH_ZOOM = IS_COARSE_POINTER;

  // ==========================================================
  // ✅ 로고 (URL 방식) - 유저 페이지에서도 표시만
  // ==========================================================
  const LOGO_KEY = "mm_logo_url_v1";
  const DEFAULT_LOGO_FALLBACK = "./assets/logo.png";
  const $logoImg = document.getElementById("logoImg");

  function normalizeUrlMaybe(u){
    const v = String(u || "").trim();
    if(!v) return "";
    try { return new URL(v, location.href).toString(); } catch { return v; }
  }

  function trySetLogo(url){
    return new Promise((resolve) => {
      const u = normalizeUrlMaybe(url);
      if(!u){ resolve(false); return; }
      const img = new Image();
      img.onload = () => {
        $logoImg.src = u;
        $logoImg.style.display = "block";
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = u + (u.includes("?") ? "&" : "?") + "v=" + Date.now();
    });
  }

  async function loadLogo(){
    $logoImg.style.display = "none";
    $logoImg.removeAttribute("src");
    const saved = (localStorage.getItem(LOGO_KEY) || "").trim();
    if(saved){
      const ok = await trySetLogo(saved);
      if(ok) return;
    }
    // 저장값 없거나 실패하면 기본 로고 파일 시도
    await trySetLogo(DEFAULT_LOGO_FALLBACK);
  }

  // ==========================================================
  // Storage / DB
  // ==========================================================
  const LS_KEY = "imgmap_multi_v700";
  const IDB_NAME = "imgmap_multi_db_v700";
  const IDB_STORE = "blobs";

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbGet(key){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, "readonly");
      const req = tx.objectStore(IDB_STORE).get(key);
      req.onsuccess = () => { db.close(); resolve(req.result || null); };
      req.onerror = () => { db.close(); reject(req.error); };
    });
  }

  // ==========================================================
  // Utils
  // ==========================================================
  const nowISO = () => new Date().toISOString();
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const uid = () => Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);

  function safeParse(json, fallback){ try { return JSON.parse(json); } catch { return fallback; } }
  function saveState(){
    state._updatedAt = Date.now();
    state._updatedAtISO = new Date().toISOString();
    try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
  }
  function isValidUrl(url){ try { new URL(url, location.href); return true; } catch { return false; } }

  // ==========================================================
  // Config
  // ==========================================================
  const DEFAULT_CATEGORIES = [
    { name:"boss", color:"#ff6b6b" },
    { name:"gather", color:"#ffd43b" },
    { name:"quest", color:"#66d9e8" },
    { name:"hunt", color:"#e6edf3" },
  ];
  const DEFAULT_MARKER_RADIUS_PX = 10;
  const DEFAULT_LABEL_COLOR = "#e6edf3";
  const DEFAULT_LABEL_WEIGHT = 900;
  const LABEL_SIZE_RATIO = 1.5;
  const calcLabelSizeFromRadius = (r) => Math.round(r * LABEL_SIZE_RATIO);
  const markerScaleDenom = () => (SCALE_MARKERS_WITH_ZOOM ? 1 : view.scale);

  // ==========================================================
  // Data Model
  // ==========================================================
  const defaultState = {
    ui: { admin:false, selectedCategory:"", selectedMarkerId:"", dimmedMarkerIds: [] },
    currentGameId: "",
    currentPageId: "",
    games: [{
      id: uid(),
      name: "Map Demo",
      categories: structuredClone(DEFAULT_CATEGORIES),
      pages: [{
        id: uid(),
        name: "1번마을",
        map: { imageKey:"", imageUrl:"", width:2200, height:1400 },
        markers: [],
        links: []
      }]
    }]
  };

  const loaded = safeParse(localStorage.getItem(LS_KEY) || "", null);
  const state = (loaded && loaded.games && Array.isArray(loaded.games)) ? loaded : structuredClone(defaultState);

  // 유저 페이지는 admin 항상 false
  if(!state.ui) state.ui = structuredClone(defaultState.ui);
  state.ui.admin = false;
  if(!Array.isArray(state.ui.dimmedMarkerIds)) state.ui.dimmedMarkerIds = [];
  if(!Array.isArray(state.games) || state.games.length === 0) state.games = structuredClone(defaultState.games);

  for(const g of state.games){
    if(!g.id) g.id = uid();
    if(typeof g.name !== "string") g.name = "Game";
    if(!Array.isArray(g.categories) || g.categories.length === 0) g.categories = structuredClone(DEFAULT_CATEGORIES);
    if(!Array.isArray(g.pages) || g.pages.length === 0){
      g.pages = [{ id: uid(), name:"1번마을", map:{imageKey:"", imageUrl:"", width:2200, height:1400}, markers:[], links:[] }];
    }
    for(const p of g.pages){
      if(!p.id) p.id = uid();
      if(typeof p.name !== "string") p.name = "Page";
      if(!p.map) p.map = { imageKey:"", imageUrl:"", width:2200, height:1400 };
      if(typeof p.map.imageUrl !== "string") p.map.imageUrl = "";
      if(typeof p.map.width !== "number" || !isFinite(p.map.width)) p.map.width = 2200;
      if(typeof p.map.height !== "number" || !isFinite(p.map.height)) p.map.height = 1400;
      if(!Array.isArray(p.markers)) p.markers = [];
      if(!Array.isArray(p.links)) p.links = [];
    }
  }

  function getGameById(id){ return state.games.find(g => g.id === id) || null; }
  function getCurrentGame(){
    if(!state.currentGameId) state.currentGameId = state.games[0].id;
    const g = getGameById(state.currentGameId);
    if(!g){ state.currentGameId = state.games[0].id; return state.games[0]; }
    return g;
  }
  function getPageById(game, pid){ return game.pages.find(p => p.id === pid) || null; }
  function getCurrentPage(){
    const g = getCurrentGame();
    if(!state.currentPageId) state.currentPageId = g.pages[0].id;
    const p = getPageById(g, state.currentPageId);
    if(!p){ state.currentPageId = g.pages[0].id; return g.pages[0]; }
    return p;
  }
  function currentCategories(){ return getCurrentGame().categories; }
  function currentMarkers(){ return getCurrentPage().markers; }
  function currentLinks(){ return getCurrentPage().links; }
  function currentMap(){ return getCurrentPage().map; }

  function setCurrentGame(gameId){
    const g = getGameById(gameId);
    if(!g) return;
    state.currentGameId = gameId;
    state.currentPageId = g.pages[0]?.id || "";
    state.ui.selectedMarkerId = "";
    state.ui.selectedCategory = "";
    state.ui.dimmedMarkerIds = [];
    saveState();
    refreshAll();
    loadMapImageForCurrentPage();
  }
  function setCurrentPage(pageId){
    const g = getCurrentGame();
    const p = getPageById(g, pageId);
    if(!p) return;
    state.currentPageId = pageId;
    state.ui.selectedMarkerId = "";
    state.ui.dimmedMarkerIds = [];
    saveState();
    refreshAll();
    loadMapImageForCurrentPage();
  }

  // ==========================================================
  // Chain / labels
  // ==========================================================
  function getCategoryColor(name){
    const c = currentCategories().find(x => x.name === name);
    return c?.color || "#e6edf3";
  }
  function getMarkerColor(m){
    const ov = (m.colorOverride || "").trim();
    return ov ? ov : getCategoryColor(m.category);
  }
  function getMarkerLabel(m){
    const t = (m.title || "").trim();
    return t ? t : (m.category || "").trim();
  }
  function getUserYoutubeDisplay(m){
    const name = (m.youtubeLabel || "").trim();
    if(name) return name;
    const t = (m.title || "").trim();
    if(t) return t;
    return "유튜브";
  }

  function getSortedGroupMarkers(groupId){
    return currentMarkers()
      .filter(x => Number(x.groupId||0) === Number(groupId||0))
      .sort((a,b) => (a.createdAt||"").localeCompare(b.createdAt||""));
  }

  function computeChainsForGroup(groupId){
    const list = getSortedGroupMarkers(groupId);
    const chains = [];
    let chainIndex = -1;
    for(let i=0;i<list.length;i++){
      const m = list[i];
      const isStart = (i===0) || !!m.chainStart;
      if(isStart){
        chainIndex++;
        chains.push({ groupId:Number(groupId||0), chainIndex, masterId:m.id, ids:[m.id] });
      }else{
        if(chainIndex < 0){
          chainIndex = 0;
          chains.push({ groupId:Number(groupId||0), chainIndex, masterId:m.id, ids:[m.id] });
        }else{
          chains[chainIndex].ids.push(m.id);
        }
      }
    }
    return chains;
  }

  function buildNumberMap(){
    const map = new Map();
    const markers = currentMarkers();
    const groups = new Set(markers.map(m => Number(m.groupId||0)));
    for(const g of groups){
      const chains = computeChainsForGroup(g);
      for(const ch of chains){
        const ids = ch.ids
          .map(id => markers.find(m => m.id === id))
          .filter(Boolean)
          .sort((a,b)=> (a.createdAt||"").localeCompare(b.createdAt||""))
          .map(m => m.id);
        for(let i=0;i<ids.length;i++) map.set(ids[i], i+1);
      }
    }
    return map;
  }

  // ==========================================================
  // DOM
  // ==========================================================
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const centerStage = document.getElementById("centerStage");

  const categoryBar = document.getElementById("categoryBar");
  const countInfo = document.getElementById("countInfo");

  const pageBadge = document.getElementById("pageBadge");
  const pageList = document.getElementById("pageList");

  const selectedHeader = document.getElementById("selectedHeader");
  const youtubeBox = document.getElementById("youtubeBox");

  const hoverOverlay = document.getElementById("hoverOverlay");
  const hoverYt = document.getElementById("hoverYt");
  const hoverMemo = document.getElementById("hoverMemo");

  const resetDimBtn = document.getElementById("resetDimBtn");

  // game dropdown
  const gameTitleBtn = document.getElementById("gameTitleBtn");
  const gameTitleText = document.getElementById("gameTitleText");
  const gameDrop = document.getElementById("gameDrop");

  // ==========================================================
  // Map image load per page (URL -> fallback IDB)
  // ==========================================================
  const mapImg = new Image();
  mapImg.crossOrigin = "anonymous";
  let mapImgReady = false;
  let mapObjectUrl = null;

  function currentMapImageKey(){
    const g = getCurrentGame();
    const p = getCurrentPage();
    return `mapimg_${g.id}_${p.id}`;
  }

  async function loadMapImageForCurrentPage(){
    mapImgReady = false;
    if(mapObjectUrl){
      URL.revokeObjectURL(mapObjectUrl);
      mapObjectUrl = null;
    }
    const key = currentMapImageKey();
    const mp = currentMap();
    const url = (mp.imageUrl || "").trim();

    if(url && isValidUrl(url)){
      const abs = new URL(url, location.href).toString();
      mapImg.onload = () => {
        mapImgReady = true;
        mp.width = mapImg.naturalWidth || mapImg.width;
        mp.height = mapImg.naturalHeight || mapImg.height;
        saveState();
        resetView();
        draw();
      };
      mapImg.onerror = async () => {
        const blob = await idbGet(key).catch(()=>null);
        if(blob){
          mapObjectUrl = URL.createObjectURL(blob);
          mapImg.onload = () => {
            mapImgReady = true;
            mp.width = mapImg.naturalWidth || mapImg.width;
            mp.height = mapImg.naturalHeight || mapImg.height;
            saveState();
            resetView();
            draw();
          };
          mapImg.onerror = () => { mapImgReady = false; draw(); };
          mapImg.src = mapObjectUrl;
        }else{
          mapImgReady = false;
          draw();
        }
      };
      // ✅ 캐시 우회(모바일 포함)
      mapImg.src = abs + (abs.includes("?") ? "&" : "?") + "v=" + Date.now();
      return;
    }

    const blob = await idbGet(key).catch(()=>null);
    if(blob){
      mapObjectUrl = URL.createObjectURL(blob);
      mapImg.onload = () => {
        mapImgReady = true;
        mp.width = mapImg.naturalWidth || mapImg.width;
        mp.height = mapImg.naturalHeight || mapImg.height;
        saveState();
        resetView();
        draw();
      };
      mapImg.onerror = () => { mapImgReady = false; draw(); };
      mapImg.src = mapObjectUrl;
      return;
    }

    mapImgReady = false;
    draw();
  }

  // ==========================================================
  // View
  // ==========================================================
  const view = { scale:1, minScale:0.05, maxScale:10, offsetX:0, offsetY:0 };

  /* ✅ (3) 모바일 세로에서 좌우/상하가 벗어나지 않도록 오프셋 클램프 */
  function constrainView(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const mp = currentMap();
    const mw = mp.width * view.scale;
    const mh = mp.height * view.scale;

    // X
    if(mw <= w){
      view.offsetX = (w - mw) / 2;
    }else{
      const minX = w - mw;
      const maxX = 0;
      view.offsetX = clamp(view.offsetX, minX, maxX);
    }

    // Y
    if(mh <= h){
      view.offsetY = (h - mh) / 2;
    }else{
      const minY = h - mh;
      const maxY = 0;
      view.offsetY = clamp(view.offsetY, minY, maxY);
    }
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = isIOS ? 1 : (window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    constrainView(); /* ✅ */
    draw();
  }
  window.addEventListener("resize", resizeCanvas);

  function worldToScreen(wx, wy){ return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY }; }
  function screenToWorld(sx, sy){ return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale }; }

  function resetView(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const mp = currentMap();
    const mw = mp.width, mh = mp.height;
    const s = Math.min(w / mw, h / mh) * 0.95;
    view.scale = clamp(s, view.minScale, view.maxScale);
    view.offsetX = (w - mw * view.scale) / 2;
    view.offsetY = (h - mh * view.scale) / 2;
    constrainView(); /* ✅ */
  }

  // ==========================================================
  // Game dropdown (user: 이동만)
  // ==========================================================
  let gameDropOpen = false;
  function closeGameDrop(){ gameDropOpen = false; gameDrop.style.display = "none"; }
  function openGameDrop(){ gameDropOpen = true; rebuildGameDrop(); gameDrop.style.display = "block"; }

  gameTitleBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    if(gameDropOpen) closeGameDrop(); else openGameDrop();
  });
  window.addEventListener("click", () => closeGameDrop());
  gameDrop.addEventListener("click", (e) => e.stopPropagation());

  function rebuildGameDrop(){
    const gcur = getCurrentGame();
    gameDrop.innerHTML = "";
    for(const g of state.games){
      const item = document.createElement("div");
      item.className = "item";
      const isActive = (g.id === gcur.id);
      item.style.borderColor = isActive ? "rgba(57,217,138,.55)" : "rgba(39,52,74,.75)";

      const pagesCount = g.pages?.length || 0;

      const left = document.createElement("div");
      left.className = "left";
      left.innerHTML = `
        <div class="gname">${escapeHtml(g.name)}</div>
        <div class="gmeta">페이지 ${pagesCount}개</div>
      `;

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.gap = "6px";

      const goBtn = document.createElement("button");
      goBtn.className = "smallBtn";
      goBtn.type = "button";
      goBtn.textContent = isActive ? "선택됨" : "이동";
      goBtn.disabled = isActive;
      goBtn.addEventListener("click", () => {
        setCurrentGame(g.id);
        closeGameDrop();
      });

      right.appendChild(goBtn);
      item.appendChild(left);
      item.appendChild(right);
      gameDrop.appendChild(item);
    }
  }

  // ==========================================================
  // Page list
  // ==========================================================
  function rebuildPageList(){
    const g = getCurrentGame();
    const curPage = getCurrentPage();
    pageBadge.textContent = `${g.name} / ${curPage.name}`;
    pageList.innerHTML = "";

    for(const p of g.pages){
      const btn = document.createElement("button");
      btn.className = "pageBtn" + (p.id === curPage.id ? " active" : "");
      btn.type = "button";

      const left = document.createElement("div");
      left.style.minWidth = "0";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = p.name || "Page";

      left.appendChild(name);
      btn.addEventListener("click", () => setCurrentPage(p.id));
      btn.appendChild(left);
      pageList.appendChild(btn);
    }
  }

  // ==========================================================
  // Category bar
  // ==========================================================
  function rebuildCategoryBar(){
    categoryBar.innerHTML = "";
    categoryBar.appendChild(makeCatButton("전체", "", "#223042"));
    for(const c of currentCategories()){
      categoryBar.appendChild(makeCatButton(c.name, c.name, c.color || "#e6edf3"));
    }
  }

  function makeCatButton(label, value, color){
    const btn = document.createElement("button");
    btn.className = "catBtn" + ((state.ui.selectedCategory === value) ? " active" : "");

    const dot = document.createElement("span");
    dot.className = "catDot";
    dot.style.background = color || "#223042";
    btn.appendChild(dot);

    const txt = document.createElement("span");
    txt.textContent = label;
    btn.appendChild(txt);

    btn.addEventListener("click", () => {
      state.ui.selectedCategory = value;
      saveState();
      rebuildCategoryBar();

      if(state.ui.selectedMarkerId){
        const m = currentMarkers().find(x => x.id === state.ui.selectedMarkerId);
        if(m && value && m.category !== value){
          state.ui.selectedMarkerId = "";
          saveState();
        }
      }
      renderSelectedPanel();
      draw();
    });

    return btn;
  }

  function getVisibleMarkers(){
    const cat = state.ui.selectedCategory || "";
    if(!cat) return currentMarkers();
    return currentMarkers().filter(m => m.category === cat);
  }

  // ==========================================================
  // Selected panel
  // ==========================================================
  function renderSelectedPanel(){
    const m = currentMarkers().find(x => x.id === state.ui.selectedMarkerId);
    if(!m){
      selectedHeader.textContent = "선택한 마커";
      youtubeBox.textContent = "-";
      return;
    }
    const name = (m.title || "").trim() || "(이름 없음)";
    selectedHeader.textContent = `선택한 마커: ${name}`;

    const url = (m.youtubeUrl || "").trim();
    const display = getUserYoutubeDisplay(m);

    if(url && isValidUrl(url)){
      youtubeBox.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(display)}</a>`;
    }else{
      youtubeBox.textContent = display ? display : "없음";
    }
  }

  // ==========================================================
  // Hover overlay
  // ==========================================================
  let overlayPinned = false;
  let pinnedMarkerId = "";

  function hideHoverOverlay(force=false){
    if(force){ hoverOverlay.style.display = "none"; return; }
    if(overlayPinned) return;
    hoverOverlay.style.display = "none";
  }
  function unpinOverlay(){
    overlayPinned = false;
    pinnedMarkerId = "";
    hideHoverOverlay(true);
  }
  function positionOverlay(clientX, clientY){
    const stageRect = centerStage.getBoundingClientRect();
    const pad = 10;
    let x = clientX - stageRect.left + 16;
    let y = clientY - stageRect.top + 16;

    hoverOverlay.style.left = x + "px";
    hoverOverlay.style.top = y + "px";
    hoverOverlay.style.display = "block";

    const overlayRect = hoverOverlay.getBoundingClientRect();
    const maxX = stageRect.width - overlayRect.width - pad;
    const maxY = stageRect.height - overlayRect.height - pad;

    x = clamp(x, pad, Math.max(pad, maxX));
    y = clamp(y, pad, Math.max(pad, maxY));

    hoverOverlay.style.left = x + "px";
    hoverOverlay.style.top = y + "px";
  }
  function renderOverlayForMarker(m){
    hoverMemo.value = m.memo || "";
    const url = (m.youtubeUrl || "").trim();
    if(url && isValidUrl(url)){
      const displayName = escapeHtml(getUserYoutubeDisplay(m));
      hoverYt.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${displayName}</a>`;
    }else{
      hoverYt.innerHTML = `<span class="muted">유튜브 없음</span>`;
    }
  }
  function showHoverOverlayForMarker(m, clientX, clientY){
    if(overlayPinned) return;
    renderOverlayForMarker(m);
    positionOverlay(clientX, clientY);
  }
  function showPinnedOverlayForMarker(m, clientX, clientY){
    overlayPinned = true;
    pinnedMarkerId = m.id;
    renderOverlayForMarker(m);
    positionOverlay(clientX, clientY);
  }

  hoverOverlay.addEventListener("mousedown", (e) => e.stopPropagation());
  hoverOverlay.addEventListener("click", (e) => e.stopPropagation());
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && overlayPinned){
      unpinOverlay();
      draw();
    }
  });

  // ==========================================================
  // User: dim reset
  // ==========================================================
  resetDimBtn.addEventListener("click", () => {
    state.ui.dimmedMarkerIds = [];
    saveState();
    draw();
  });

  // ==========================================================
  // Input (pan/zoom + user interactions)
  // ==========================================================
  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }
  function worldToMarkerScreen(m){
    const mp = currentMap();
    const wx = m.x * mp.width;
    const wy = m.y * mp.height;
    return worldToScreen(wx, wy);
  }
  function findMarkerAtScreen(sx, sy){
    const list = getVisibleMarkers();
    for(let i=list.length-1; i>=0; i--){
      const m = list[i];
      const p = worldToMarkerScreen(m);
      const rPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
      const dx = sx - p.x, dy = sy - p.y;
      if(dx*dx + dy*dy <= rPx*rPx) return m;
    }
    return null;
  }

  function getLabelRectScreen(m){
    const p = worldToMarkerScreen(m);
    const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
    const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
    const weight = (typeof m.labelWeight === "number" ? m.labelWeight : DEFAULT_LABEL_WEIGHT);
    const label = getMarkerLabel(m);

    ctx.save();
    ctx.font = `${weight} ${sizePx}px system-ui`;
    const w = ctx.measureText(label).width;
    ctx.restore();

    const gap = 10;
    const x = p.x + radiusPx + gap;
    const yMid = p.y;
    const h = sizePx * 1.2;

    return { x, y: yMid - h/2, w, h };
  }

  function findMarkerLabelAtScreen(sx, sy){
    const list = getVisibleMarkers();
    for(let i=list.length-1; i>=0; i--){
      const m = list[i];
      const r = getLabelRectScreen(m);
      if(sx >= r.x && sx <= (r.x + r.w) && sy >= r.y && sy <= (r.y + r.h)) return m;
    }
    return null;
  }

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  canvas.addEventListener("wheel", (evt) => {
    evt.preventDefault();
    const { x:sx, y:sy } = getPointerPos(evt);

    const before = screenToWorld(sx, sy);
    const delta = -evt.deltaY;
    const zoomFactor = Math.exp(delta * 0.0015);

    view.scale = clamp(view.scale * zoomFactor, view.minScale, view.maxScale);

    const after = screenToWorld(sx, sy);
    view.offsetX += (after.x - before.x) * view.scale;
    view.offsetY += (after.y - before.y) * view.scale;

    constrainView(); /* ✅ */
    draw();
  }, { passive:false });

  let isPanning = false;
  let panStart = { x:0, y:0 };
  let viewStart = { ox:0, oy:0 };

  canvas.addEventListener("mousedown", (evt) => {
    const { x:sx, y:sy } = getPointerPos(evt);
    // 좌클릭: 마커 선택 / 아니면 패닝
    if(evt.button !== 0) return;

    const m = findMarkerAtScreen(sx, sy);
    if(m){
      state.ui.selectedMarkerId = m.id;

      /* ✅ (2) 같은 마커를 다시 클릭하면 불투명화 해제(토글) */
      const set = new Set(state.ui.dimmedMarkerIds || []);
      if(set.has(m.id)) set.delete(m.id);
      else set.add(m.id);
      state.ui.dimmedMarkerIds = [...set];

      saveState();
      renderSelectedPanel();
      draw();
      return;
    }

    isPanning = true;
    panStart = { x:sx, y:sy };
    viewStart = { ox:view.offsetX, oy:view.offsetY };
  });

  canvas.addEventListener("mousemove", (evt) => {
    const { x:sx, y:sy } = getPointerPos(evt);

    if(isPanning){
      const dx = sx - panStart.x;
      const dy = sy - panStart.y;
      view.offsetX = viewStart.ox + dx;
      view.offsetY = viewStart.oy + dy;
      constrainView(); /* ✅ */
      draw();
      return;
    }

    // 유저: 라벨에 hover 시 오버레이
    if(overlayPinned) return;

    const labelHit = findMarkerLabelAtScreen(sx, sy);
    if(labelHit){
      showHoverOverlayForMarker(labelHit, evt.clientX, evt.clientY);
    }else{
      hideHoverOverlay();
    }
  });

  window.addEventListener("mouseup", () => { isPanning = false; });

  // 라벨 좌클릭: 오버레이 고정
  canvas.addEventListener("click", (evt) => {
    const { x:sx, y:sy } = getPointerPos(evt);
    const m = findMarkerLabelAtScreen(sx, sy);
    if(m){
      showPinnedOverlayForMarker(m, evt.clientX, evt.clientY);
    }else{
      if(overlayPinned){
        unpinOverlay();
        draw();
      }
    }
  });

  // ==========================================================
  // Draw
  // ==========================================================
  function drawBackgroundGrid(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    ctx.save();
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#070b12";
    ctx.fillRect(0,0,w,h);

    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#243447";
    for(let x=0; x<w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0; y<h; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();
  }

  function drawArrow(ax, ay, bx, by){
    const dx = bx - ax;
    const dy = by - ay;
    const len = Math.hypot(dx, dy);
    if(len < 1e-6) return;

    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();

    const ux = dx / len;
    const uy = dy / len;
    const head = 10 / view.scale;
    const angle = Math.atan2(uy, ux);
    const a1 = angle + Math.PI * 0.85;
    const a2 = angle - Math.PI * 0.85;

    const hx1 = bx + Math.cos(a1) * head;
    const hy1 = by + Math.sin(a1) * head;
    const hx2 = bx + Math.cos(a2) * head;
    const hy2 = by + Math.sin(a2) * head;

    ctx.beginPath();
    ctx.moveTo(bx, by);
    ctx.lineTo(hx1, hy1);
    ctx.lineTo(hx2, hy2);
    ctx.closePath();
    ctx.fill();
  }

  function shrinkSegmentToCircles(ax, ay, arWorld, bx, by, brWorld){
    const dx = bx - ax;
    const dy = by - ay;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len;
    const uy = dy / len;
    const aShrink = Math.min(arWorld, len * 0.49);
    const bShrink = Math.min(brWorld, len * 0.49);
    const sx = ax + ux * aShrink;
    const sy = ay + uy * aShrink;
    const ex = bx - ux * bShrink;
    const ey = by - uy * bShrink;
    return { sx, sy, ex, ey };
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    drawBackgroundGrid();

    const numMap = buildNumberMap();
    const mp = currentMap();

    ctx.save();
    ctx.translate(view.offsetX, view.offsetY);
    ctx.scale(view.scale, view.scale);

    if(mapImgReady){
      ctx.drawImage(mapImg, 0, 0, mp.width, mp.height);
    }else{
      ctx.fillStyle = "#0d131c";
      ctx.fillRect(0,0,mp.width, mp.height);
      ctx.strokeStyle = "#223042";
      ctx.lineWidth = 4 / view.scale;
      ctx.strokeRect(0,0,mp.width, mp.height);
      // ✅ 지도 자리 문구 없음(요청사항 유지)
    }

    const visible = getVisibleMarkers();
    const visibleSet = new Set(visible.map(m => m.id));
    countInfo.textContent = `표시 중 마커: ${visible.length} / 페이지 전체: ${currentMarkers().length}`;

    // links
    ctx.save();
    ctx.strokeStyle = "#ffffff";
    ctx.fillStyle = "#ffffff";
    ctx.globalAlpha = 0.85;
    ctx.lineWidth = 2 / view.scale;

    for(const l of currentLinks()){
      if(!visibleSet.has(l.fromId) || !visibleSet.has(l.toId)) continue;
      const a = currentMarkers().find(m => m.id === l.fromId);
      const b = currentMarkers().find(m => m.id === l.toId);
      if(!a || !b) continue;

      const ax = a.x * mp.width, ay = a.y * mp.height;
      const bx = b.x * mp.width, by = b.y * mp.height;

      const arPx = (typeof a.radiusPx === "number" ? a.radiusPx : DEFAULT_MARKER_RADIUS_PX);
      const brPx = (typeof b.radiusPx === "number" ? b.radiusPx : DEFAULT_MARKER_RADIUS_PX);
      const arWorld = arPx / markerScaleDenom();
      const brWorld = brPx / markerScaleDenom();

      const seg = shrinkSegmentToCircles(ax, ay, arWorld, bx, by, brWorld);
      drawArrow(seg.sx, seg.sy, seg.ex, seg.ey);
    }
    ctx.restore();

    // markers
    const dimSet = new Set(state.ui.dimmedMarkerIds || []);
    for(const m of visible){
      const wx = m.x * mp.width;
      const wy = m.y * mp.height;

      const isSelected = (state.ui.selectedMarkerId === m.id);
      const color = getMarkerColor(m);

      const radiusPx = (typeof m.radiusPx === "number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
      const denom = markerScaleDenom();
      const r = radiusPx / denom;

      const isDim = dimSet.has(m.id);

      ctx.save();
      ctx.translate(wx, wy);

      ctx.globalAlpha = isDim ? 0.30 : 1.0;

      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fill();

      ctx.lineWidth = (isSelected ? 4 : 2) / denom;
      ctx.strokeStyle = isSelected ? "#ffd43b" : "#0b0f14";
      ctx.stroke();

      const num = numMap.get(m.id);
      if(num != null){
        ctx.save();
        ctx.fillStyle = "#000000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const fs = Math.max((radiusPx * 0.95) / denom, 9 / denom);
        ctx.font = `900 ${fs}px system-ui`;
        ctx.fillText(String(num), 0, 0);
        ctx.restore();
      }

      ctx.globalAlpha = 1.0;

      const sizePx = (typeof m.labelSizePx === "number" ? m.labelSizePx : calcLabelSizeFromRadius(radiusPx));
      const weight = (typeof m.labelWeight === "number" ? m.labelWeight : DEFAULT_LABEL_WEIGHT);
      const lcolor = (typeof m.labelColor === "string" && /^#([0-9a-fA-F]{6})$/.test(m.labelColor)) ? m.labelColor : DEFAULT_LABEL_COLOR;

      ctx.fillStyle = lcolor;
      ctx.font = `${weight} ${sizePx / denom}px system-ui`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      const gap = 10 / denom;
      ctx.fillText(getMarkerLabel(m), r + gap, 0);

      ctx.restore();
    }

    ctx.restore();
  }

  // ==========================================================
  // Refresh helpers
  // ==========================================================
  function refreshHeaderTitle(){
    const g = getCurrentGame();
    gameTitleText.textContent = g.name || "Map Demo";
  }
  function refreshAll(){
    refreshHeaderTitle();
    rebuildGameDrop();
    rebuildPageList();
    rebuildCategoryBar();
    renderSelectedPanel();
  }

  // ==========================================================
  // Init sample markers (only once)
  // ==========================================================
  function ensureSampleMarkersOnce(){
    const p = getCurrentPage();
    if(p.markers.length > 0) return;
    p.markers = [
      {
        id: uid(),
        x:0.35, y:0.42,
        category:"boss",
        title:"보스",
        youtubeUrl:"https://www.youtube.com/watch?v=dQw4w9WgXcQ",
        youtubeLabel:"보스 영상",
        createdAt: nowISO(),
        colorOverride:"",
        radiusPx: DEFAULT_MARKER_RADIUS_PX,
        labelSizePx: calcLabelSizeFromRadius(DEFAULT_MARKER_RADIUS_PX),
        labelWeight: DEFAULT_LABEL_WEIGHT,
        labelColor: DEFAULT_LABEL_COLOR,
        groupId: 0,
        chainStart: true,
        memo: ""
      },
      {
        id: uid(),
        x:0.58, y:0.55,
        category:"boss",
        title:"채집",
        youtubeUrl:"",
        youtubeLabel:"",
        createdAt: nowISO(),
        colorOverride:"",
        radiusPx: DEFAULT_MARKER_RADIUS_PX,
        labelSizePx: calcLabelSizeFromRadius(DEFAULT_MARKER_RADIUS_PX),
        labelWeight: DEFAULT_LABEL_WEIGHT,
        labelColor: DEFAULT_LABEL_COLOR,
        groupId: 0,
        chainStart: false,
        memo: ""
      },
      {
        id: uid(),
        x:0.22, y:0.63,
        category:"boss",
        title:"퀘스트",
        youtubeUrl:"",
        youtubeLabel:"",
        createdAt: nowISO(),
        colorOverride:"",
        radiusPx: DEFAULT_MARKER_RADIUS_PX,
        labelSizePx: calcLabelSizeFromRadius(DEFAULT_MARKER_RADIUS_PX),
        labelWeight: DEFAULT_LABEL_WEIGHT,
        labelColor: DEFAULT_LABEL_COLOR,
        groupId: 0,
        chainStart: false,
        memo: ""
      },
    ];
    saveState();
  }

  // ==========================================================
  // Final init
  // ==========================================================
  async function init(){
    getCurrentGame();
    getCurrentPage();
    ensureSampleMarkersOnce();

    for(const m of currentMarkers()){
      if(typeof m.title !== "string") m.title = "";
      if(typeof m.youtubeUrl !== "string") m.youtubeUrl = "";
      if(typeof m.youtubeLabel !== "string") m.youtubeLabel = "";
      if(typeof m.colorOverride !== "string") m.colorOverride = "";
      if(typeof m.category !== "string") m.category = currentCategories()[0]?.name || "default";
      if(typeof m.createdAt !== "string") m.createdAt = nowISO();
      if(typeof m.radiusPx !== "number" || !isFinite(m.radiusPx)) m.radiusPx = DEFAULT_MARKER_RADIUS_PX;
      if(typeof m.labelSizePx !== "number" || !isFinite(m.labelSizePx)) m.labelSizePx = calcLabelSizeFromRadius(m.radiusPx);
      if(typeof m.labelWeight !== "number" || !isFinite(m.labelWeight)) m.labelWeight = DEFAULT_LABEL_WEIGHT;
      if(typeof m.labelColor !== "string") m.labelColor = DEFAULT_LABEL_COLOR;
      if(typeof m.groupId !== "number" || !isFinite(m.groupId)) m.groupId = 0;
      if(typeof m.chainStart !== "boolean") m.chainStart = false;
      if(typeof m.memo !== "string") m.memo = "";
    }

    saveState();

    await loadLogo();
    refreshAll();
    resizeCanvas();
    resetView();
    await loadMapImageForCurrentPage();
    draw();

    // ✅ (1) init 완료 후 화면 표시
    document.documentElement.classList.add("ready");
  }

  init();
})();
</script>
</body>
</html>
