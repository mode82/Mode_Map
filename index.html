<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Multi-Map Demo v7.0.0</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 18px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }

    /* ===== [PATCH: mobile page fixed] =====
       - 모바일에서 손가락으로 드래그할 때 페이지(전체 레이아웃)가 좌/우로 밀리며
         우측에 빈 공간이 생기는 현상을 방지.
       - 메뉴/패널은 고정, 지도(#canvas) 영역만 내부에서 확대/이동.
       (기존 로직/디자인은 건드리지 않고, 문서 스크롤만 잠금)
    ====================================== */
    html, body{
      width:100%;
      height:100%;
      overflow:hidden;              /* ✅ 문서 자체 스크롤(가로/세로) 차단 */
      overscroll-behavior: none;    /* ✅ (지원 브라우저) 바운스/넘김 방지 */
    }
    #canvas{
      touch-action: none;           /* ✅ 지도 조작은 캔버스 내부에서만 */
    }

    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.85);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight: 800;
      letter-spacing:.2px;
      cursor:pointer;
      user-select:none;
    }
    .badge{
      font-size:12px;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: linear-gradient(180deg, rgba(14,22,38,.85), rgba(10,16,28,.75));
      color: rgba(231,238,248,.9);
    }

    .spacer{ flex:1; }

    .btn{
      appearance:none;
      border:1px solid rgba(39,52,74,.9);
      background: linear-gradient(180deg, rgba(14,22,38,.85), rgba(10,16,28,.75));
      color: rgba(231,238,248,.95);
      padding:10px 12px;
      border-radius: var(--r14);
      cursor:pointer;
      font-weight:700;
      box-shadow: var(--shadow2);
      user-select:none;
      transition: transform .08s ease, border-color .15s ease, background .15s ease;
      white-space:nowrap;
    }
    .btn:hover{ border-color: rgba(124,196,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.danger{ border-color: rgba(255,93,93,.55); }
    .btn.danger:hover{ border-color: rgba(255,93,93,.9); }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr 380px;
      height: calc(100vh - 56px);
    }

    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
    }

    .panel.left{ border-right:1px solid rgba(31,42,58,.85); }
    .panel.right{ border-left:1px solid rgba(31,42,58,.85); }

    .center{ position:relative; overflow:hidden; }
    #canvas{ width:100%; height:100%; display:block; background:#0b0f14; }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }
    .section h3{
      margin:0 0 10px 0;
      font-size: 13px;
      letter-spacing:.2px;
      color: rgba(231,238,248,.92);
    }
    .muted{ color: rgba(159,176,198,.92); font-size: 12px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row > *{ flex:1; }

    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      box-sizing:border-box;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(6,10,18,.7);
      color: rgba(231,238,248,.96);
      padding:10px 12px;
      border-radius: var(--r14);
      outline:none;
      font-size: 14px;
    }
    textarea{ min-height: 78px; resize: vertical; }
    label{ font-size:12px; color: rgba(159,176,198,.96); display:block; margin: 8px 0 6px; }

    .pillbar{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      border:1px solid rgba(39,52,74,.9);
      background: rgba(6,10,18,.55);
      padding:8px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 13px;
      color: rgba(231,238,248,.92);
      user-select:none;
      display:inline-flex;
      gap:8px;
      align-items:center;
      transition: border-color .15s ease, transform .08s ease;
    }
    .pill:active{ transform: translateY(1px); }
    .pill.active{
      border-color: rgba(124,196,255,.65);
      box-shadow: 0 0 0 2px rgba(124,196,255,.12) inset;
    }
    .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; background:rgba(159,176,198,.65); }
    .dot.red{ background: var(--danger); }
    .dot.yellow{ background: var(--warn); }
    .dot.blue{ background: var(--accent); }
    .dot.green{ background: var(--ok); }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      align-items:center;
      margin-top:10px;
    }
    .kv .k{ color: rgba(159,176,198,.95); font-size:12px; }
    .kv .v{ font-family: var(--mono); font-size:12px; color: rgba(231,238,248,.92); }

    .mini{
      font-size:12px;
      color: rgba(159,176,198,.92);
      line-height:1.4;
    }

    /* Hover overlay (marker note & yt) */
    #hoverOverlay{
      position:absolute;
      pointer-events:none;
      z-index:20;
      min-width: 260px;
      max-width: 360px;
      display:none;
    }
    #hoverOverlay .box{
      border:1px solid rgba(39,52,74,.95);
      background: rgba(10,16,28,.92);
      border-radius: var(--r16);
      box-shadow: var(--shadow);
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #hoverOverlay .title{
      font-weight:800;
      font-size:13px;
      margin:0 0 6px 0;
      color: rgba(231,238,248,.95);
    }
    #hoverOverlay .note{
      white-space: pre-wrap;
      font-size:12px;
      line-height:1.45;
      color: rgba(231,238,248,.85);
      margin:0 0 8px 0;
    }
    #hoverOverlay .yt{
      font-size:12px;
      color: rgba(159,176,198,.95);
      display:flex;
      gap:8px;
      align-items:center;
    }
    #hoverOverlay .yt a{ color: rgba(231,238,248,.95); text-decoration:none; }
    #hoverOverlay .yt a:hover{ text-decoration: underline; }

    /* Modals */
    .modalBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:999;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .modal{
      width:min(860px, 100%);
      max-height: min(86vh, 900px);
      overflow:auto;
      border:1px solid rgba(39,52,74,.95);
      background: rgba(10,16,28,.92);
      border-radius: var(--r18);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .modal h2{ margin:0 0 8px; font-size:16px; }
    .modal .closeRow{ display:flex; justify-content:space-between; gap:10px; align-items:center; margin-bottom:10px; }
    .hint{ font-size:12px; color: rgba(159,176,198,.95); }

    /* Responsive */
    @media (max-width: 1100px){
      .wrap{
        grid-template-columns: 330px 1fr 330px;
      }
    }
    @media (max-width: 920px){
      .wrap{
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        height: calc(100vh - 56px);
      }
      .panel.left{ order:1; border-right:none; border-bottom:1px solid rgba(31,42,58,.85); }
      .center{ order:2; }
      .panel.right{ order:3; border-left:none; border-top:1px solid rgba(31,42,58,.85); }
    }
  </style>
</head>
<body>

<header>
  <div class="brand" id="brandBtn">
    <span>Map Demo</span>
    <span class="badge" id="modeBadge">USER</span>
  </div>

  <div class="spacer"></div>

  <button class="btn" id="openHelpBtn">도움말</button>
</header>

<div class="wrap">
  <!-- LEFT PANEL -->
  <aside class="panel left" id="leftPanel">

    <div class="section">
      <h3>게임</h3>
      <select id="gameSelect"></select>
      <div class="mini" style="margin-top:8px;">
        게임을 선택하면 해당 게임의 페이지(지도) 목록이 표시됩니다.
      </div>
    </div>

    <div class="section">
      <h3>페이지</h3>
      <div id="pageList" class="pillbar"></div>
      <div class="kv">
        <div class="k">현재</div>
        <div class="v" id="currentPageLabel">-</div>
      </div>
    </div>

  </aside>

  <!-- CENTER -->
  <main class="center">
    <canvas id="canvas"></canvas>

    <div id="hoverOverlay">
      <div class="box">
        <div class="title" id="hoverTitle">-</div>
        <div class="note" id="hoverNote">-</div>
        <div class="yt" id="hoverYtRow" style="display:none;">
          <span class="badge">YouTube</span>
          <a id="hoverYtLink" href="#" target="_blank" rel="noopener">열기</a>
        </div>
      </div>
    </div>
  </main>

  <!-- RIGHT PANEL -->
  <aside class="panel right" id="rightPanel">

    <div class="section">
      <h3>카테고리</h3>
      <div class="pillbar" id="categoryPills"></div>
      <div class="kv">
        <div class="k">표시 중 마커</div>
        <div class="v" id="markerCount">0</div>
      </div>
      <div class="mini" id="pageMarkerCount">페이지 전체: 0</div>
    </div>

    <div class="section">
      <h3>마커 초기화</h3>
      <button class="btn danger" id="resetDimBtn">마커 초기화</button>
    </div>

  </aside>
</div>

<!-- HELP MODAL -->
<div class="modalBackdrop" id="helpModal">
  <div class="modal">
    <div class="closeRow">
      <h2>도움말</h2>
      <button class="btn" id="closeHelpBtn">닫기</button>
    </div>
    <div class="hint">
      • 지도는 마우스 휠/버튼 또는 제스처로 확대/축소할 수 있습니다.<br/>
      • 마커 텍스트에 마우스를 올리면 메모/유튜브 링크가 표시됩니다.<br/>
      • 유저 모드에서는 마커 클릭으로 불투명화를 토글할 수 있습니다.
    </div>
  </div>
</div>

<script>
(() => {
  // ==========================================================
  // 기존 코드 (요청: 상관없는 코드 수정 금지)
  // ==========================================================
  const LS_KEY = "interactive_multi_map_demo_v7_state";
  const DB_NAME = "interactive_multi_map_demo_v7_db";
  const DB_STORE = "maps";
  const MAX_ZOOM = 8;
  const MIN_ZOOM = 0.2;

  // ---------- util ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const clamp01 = (v) => clamp(v, 0, 1);
  const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

  function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

  // ---------- state ----------
  const defaultState = {
    version: "7.0.0",
    ui: {
      admin: false,
      gameId: "",
      pageId: "",
      selectedMarkerId: "",
      dimmedMarkerIds: [],
      pinnedOverlayMarkerId: "",
      categoryFilter: "all",
    },
    data: {
      games: [
        {
          id: "aion2",
          name: "아이온2",
          pages: [
            {
              id: "world",
              name: "전체지도",
              map: {
                width: 4096,
                height: 4096,
                imageKey: "aion2_world_map"
              },
              markers: [],
              links: []
            }
          ]
        }
      ]
    }
  };

  let state = loadState() || deepClone(defaultState);

  function saveState(){
    try{
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    }catch(e){
      console.warn("saveState error", e);
    }
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){
      console.warn("loadState error", e);
      return null;
    }
  }

  // ---------- db (maps) ----------
  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains(DB_STORE)){
          db.createObjectStore(DB_STORE);
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function dbPut(key, blob){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(blob, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
  async function dbGet(key){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get(key);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  // ---------- DOM ----------
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const modeBadge = document.getElementById("modeBadge");
  const brandBtn = document.getElementById("brandBtn");

  const gameSelect = document.getElementById("gameSelect");
  const pageList = document.getElementById("pageList");
  const currentPageLabel = document.getElementById("currentPageLabel");

  const categoryPills = document.getElementById("categoryPills");
  const markerCountEl = document.getElementById("markerCount");
  const pageMarkerCountEl = document.getElementById("pageMarkerCount");

  const resetDimBtn = document.getElementById("resetDimBtn");

  const hoverOverlay = document.getElementById("hoverOverlay");
  const hoverTitle = document.getElementById("hoverTitle");
  const hoverNote = document.getElementById("hoverNote");
  const hoverYtRow = document.getElementById("hoverYtRow");
  const hoverYtLink = document.getElementById("hoverYtLink");

  const helpModal = document.getElementById("helpModal");
  const openHelpBtn = document.getElementById("openHelpBtn");
  const closeHelpBtn = document.getElementById("closeHelpBtn");

  // ---------- view ----------
  const view = {
    zoom: 1,
    offsetX: 0,
    offsetY: 0
  };

  function currentGame(){
    return state.data.games.find(g => g.id === state.ui.gameId) || state.data.games[0];
  }
  function currentPages(){
    return currentGame().pages || [];
  }
  function currentPage(){
    return currentPages().find(p => p.id === state.ui.pageId) || currentPages()[0];
  }
  function currentMap(){
    return currentPage().map;
  }
  function currentMarkers(){
    return currentPage().markers || [];
  }

  // ---------- init ----------
  if(!state.ui.gameId){
    state.ui.gameId = state.data.games[0]?.id || "";
  }
  if(!state.ui.pageId){
    state.ui.pageId = currentPages()[0]?.id || "";
  }

  // ---------- UI builders ----------
  function rebuildGameSelect(){
    gameSelect.innerHTML = "";
    state.data.games.forEach(g => {
      const opt = document.createElement("option");
      opt.value = g.id;
      opt.textContent = g.name || g.id;
      if(g.id === state.ui.gameId) opt.selected = true;
      gameSelect.appendChild(opt);
    });
  }

  function rebuildPageList(){
    pageList.innerHTML = "";
    const pages = currentPages();
    pages.forEach(p => {
      const pill = document.createElement("div");
      pill.className = "pill" + (p.id === state.ui.pageId ? " active" : "");
      pill.textContent = p.name || p.id;
      pill.addEventListener("click", () => {
        state.ui.pageId = p.id;
        state.ui.selectedMarkerId = "";
        state.ui.pinnedOverlayMarkerId = "";
        saveState();
        rebuildPageList();
        renderHeaderLabels();
        fitToMap();
        draw();
      });
      pageList.appendChild(pill);
    });
  }

  function rebuildCategoryPills(){
    categoryPills.innerHTML = "";
    const categories = [
      { id:"all", name:"전체", dot:"" },
      { id:"boss", name:"보스", dot:"red" },
      { id:"gitel", name:"깃털", dot:"yellow" },
      { id:"cube", name:"큐브", dot:"blue" }
    ];

    categories.forEach(c => {
      const pill = document.createElement("div");
      pill.className = "pill" + (state.ui.categoryFilter === c.id ? " active" : "");
      const dot = document.createElement("span");
      dot.className = "dot " + (c.dot || "");
      pill.appendChild(dot);
      const t = document.createElement("span");
      t.textContent = c.name;
      pill.appendChild(t);

      pill.addEventListener("click", () => {
        state.ui.categoryFilter = c.id;
        saveState();
        rebuildCategoryPills();
        draw();
        updateCounts();
      });
      categoryPills.appendChild(pill);
    });
  }

  function renderHeaderLabels(){
    const g = currentGame();
    const p = currentPage();
    modeBadge.textContent = state.ui.admin ? "ADMIN" : "USER";
    currentPageLabel.textContent = `${g.name || g.id} / ${p.name || p.id}`;
  }

  // ---------- map image loading ----------
  let mapImage = new Image();
  let mapImageReady = false;

  async function loadMapImage(){
    const mp = currentMap();
    mapImageReady = false;
    mapImage = new Image();
    mapImage.onload = () => {
      mapImageReady = true;
      draw();
    };
    mapImage.onerror = () => {
      mapImageReady = false;
      draw();
    };

    const blob = await dbGet(mp.imageKey);
    if(blob){
      mapImage.src = URL.createObjectURL(blob);
    }else{
      mapImage.src = "";
    }
  }

  // ---------- geometry ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function worldToScreen(wx, wy){
    return {
      x: wx * view.zoom + view.offsetX,
      y: wy * view.zoom + view.offsetY
    };
  }
  function screenToWorld(sx, sy){
    return {
      x: (sx - view.offsetX) / view.zoom,
      y: (sy - view.offsetY) / view.zoom
    };
  }

  function fitToMap(){
    const rect = canvas.getBoundingClientRect();
    const mp = currentMap();
    const scaleX = rect.width / mp.width;
    const scaleY = rect.height / mp.height;
    view.zoom = Math.min(scaleX, scaleY);
    view.zoom = clamp(view.zoom, MIN_ZOOM, MAX_ZOOM);
    view.offsetX = (rect.width - mp.width * view.zoom)/2;
    view.offsetY = (rect.height - mp.height * view.zoom)/2;
    clampViewToBounds();
    draw();
  }

  function clampViewToBounds(){
    const rect = canvas.getBoundingClientRect();
    const mp = currentMap();
    const contentW = mp.width * view.zoom;
    const contentH = mp.height * view.zoom;

    // keep centered if smaller than viewport
    if(contentW <= rect.width){
      view.offsetX = (rect.width - contentW)/2;
    }else{
      const minX = rect.width - contentW;
      view.offsetX = clamp(view.offsetX, minX, 0);
    }
    if(contentH <= rect.height){
      view.offsetY = (rect.height - contentH)/2;
    }else{
      const minY = rect.height - contentH;
      view.offsetY = clamp(view.offsetY, minY, 0);
    }
  }

  // ---------- marker hit test ----------
  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  function markerScreenRadius(){
    return 14; // original baseline
  }

  function visibleMarkers(){
    const list = currentMarkers();
    const cat = state.ui.categoryFilter;
    if(cat === "all") return list;
    return list.filter(m => (m.category || "all") === cat);
  }

  function findMarkerAtScreen(sx, sy){
    const mp = currentMap();
    const w = screenToWorld(sx, sy);
    const mx = w.x / mp.width;
    const my = w.y / mp.height;

    const markers = visibleMarkers();
    // hit radius in normalized units based on zoom
    const rpx = markerScreenRadius() / view.zoom;
    const rnx = rpx / mp.width;
    const rny = rpx / mp.height;

    // iterate reverse for topmost
    for(let i=markers.length-1;i>=0;i--){
      const m = markers[i];
      const dx = (m.x - mx) / rnx;
      const dy = (m.y - my) / rny;
      if(dx*dx + dy*dy <= 1) return m;
    }
    return null;
  }

  // ---------- hover overlay (user) ----------
  let lastHoverMarkerId = "";
  let hoverPinned = false;

  function showHover(marker, sx, sy){
    if(!marker) return hideHover();
    const rect = canvas.getBoundingClientRect();

    hoverOverlay.style.display = "block";
    hoverOverlay.style.left = (rect.left + sx + 12) + "px";
    hoverOverlay.style.top = (rect.top + sy + 12) + "px";

    hoverTitle.textContent = marker.label || ("마커 " + (marker.num ?? ""));
    hoverNote.textContent = marker.note || "";

    const yt = marker.youtube || "";
    if(yt){
      hoverYtRow.style.display = "flex";
      hoverYtLink.href = yt;
      hoverYtLink.textContent = marker.youtubeTitle || "YouTube 링크";
    }else{
      hoverYtRow.style.display = "none";
    }
  }
  function hideHover(){
    if(hoverPinned) return;
    hoverOverlay.style.display = "none";
    lastHoverMarkerId = "";
  }

  // ---------- drawing ----------
  function draw(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    // background
    ctx.fillStyle = "#0b0f14";
    ctx.fillRect(0,0,rect.width,rect.height);

    if(mapImageReady){
      ctx.save();
      ctx.translate(view.offsetX, view.offsetY);
      ctx.scale(view.zoom, view.zoom);
      ctx.drawImage(mapImage, 0,0, currentMap().width, currentMap().height);
      ctx.restore();
    }else{
      ctx.fillStyle = "rgba(159,176,198,.25)";
      ctx.font = "14px var(--mono)";
      ctx.fillText("지도 이미지가 없습니다. (관리자에서 업로드 필요)", 18, 28);
    }

    // links
    const links = currentPage().links || [];
    const mp = currentMap();
    ctx.save();
    ctx.translate(view.offsetX, view.offsetY);
    ctx.scale(view.zoom, view.zoom);
    ctx.lineWidth = 2 / view.zoom;
    ctx.strokeStyle = "rgba(255,255,255,.75)";
    ctx.fillStyle = "rgba(255,255,255,.75)";
    links.forEach(l => {
      const a = currentMarkers().find(m => m.id === l.a);
      const b = currentMarkers().find(m => m.id === l.b);
      if(!a || !b) return;
      ctx.beginPath();
      ctx.moveTo(a.x*mp.width, a.y*mp.height);
      ctx.lineTo(b.x*mp.width, b.y*mp.height);
      ctx.stroke();
    });
    ctx.restore();

    // markers
    const markers = visibleMarkers();
    const dimmed = new Set(state.ui.dimmedMarkerIds || []);
    markers.forEach(m => {
      const wx = m.x * mp.width;
      const wy = m.y * mp.height;
      const s = worldToScreen(wx, wy);

      const isDim = dimmed.has(m.id);
      ctx.globalAlpha = isDim ? 0.30 : 1.0;

      // circle
      ctx.beginPath();
      ctx.arc(s.x, s.y, markerScreenRadius(), 0, Math.PI*2);

      // fill color by category
      const cat = m.category || "all";
      let fill = "rgba(159,176,198,.85)";
      if(cat === "boss") fill = "rgba(255,93,93,.9)";
      if(cat === "gitel") fill = "rgba(255,214,10,.92)";
      if(cat === "cube") fill = "rgba(124,196,255,.92)";

      ctx.fillStyle = fill;
      ctx.fill();

      // outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(10,16,28,.9)";
      ctx.stroke();

      // number
      ctx.globalAlpha = isDim ? 0.40 : 1.0;
      ctx.fillStyle = "rgba(10,16,28,.95)";
      ctx.font = "700 12px var(--mono)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const numText = (m.num ?? "").toString();
      ctx.fillText(numText, s.x, s.y);

      // label (next to marker)
      ctx.globalAlpha = 1.0;
      if(m.label){
        ctx.font = "700 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(231,238,248,.95)";
        ctx.fillText(m.label, s.x + 18, s.y);
      }
    });

    ctx.globalAlpha = 1.0;
  }

  // ---------- counts ----------
  function updateCounts(){
    const markers = visibleMarkers();
    markerCountEl.textContent = markers.length + " / 페이지 전체: " + currentMarkers().length;
    pageMarkerCountEl.textContent = "페이지 전체: " + currentMarkers().length;
  }

  // ---------- user interactions ----------
  let isPanning = false;
  let panStart = {x:0,y:0};
  let viewStart = {ox:0,oy:0};
  let draggingMarkerId = "";
  let dragOffsetWorld = {x:0,y:0};
  let didDrag = false;

  canvas.addEventListener("mousedown", (evt) => {
    const {x:sx,y:sy} = getPointerPos(evt);
    didDrag = false;

    const m = findMarkerAtScreen(sx,sy);
    if(m){
      state.ui.selectedMarkerId = m.id;

      if(!state.ui.admin){
        const arr = Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : [];
        const idx = arr.indexOf(m.id);
        if(idx >= 0) arr.splice(idx, 1);
        else arr.push(m.id);
        state.ui.dimmedMarkerIds = arr;

        saveState();
        draw();
        updateCounts();
        return;
      }

      // admin drag (not used in index generally)
      draggingMarkerId = m.id;
      const w = screenToWorld(sx,sy);
      const mp = currentMap();
      const mwx = m.x*mp.width;
      const mwy = m.y*mp.height;
      dragOffsetWorld = {x: mwx - w.x, y: mwy - w.y};
      draw();
      return;
    }

    isPanning = true;
    panStart = {x:sx,y:sy};
    viewStart = {ox:view.offsetX, oy:view.offsetY};
  });

  canvas.addEventListener("mousemove", (evt) => {
    const {x:sx,y:sy} = getPointerPos(evt);

    if(draggingMarkerId && state.ui.admin){
      const m = currentMarkers().find(x => x.id === draggingMarkerId);
      if(!m) return;
      const w = screenToWorld(sx,sy);
      const mp = currentMap();
      const mwx = w.x + dragOffsetWorld.x;
      const mwy = w.y + dragOffsetWorld.y;
      const nx = clamp01(mwx / mp.width);
      const ny = clamp01(mwy / mp.height);
      if(Math.abs(nx-m.x)>0.0001 || Math.abs(ny-m.y)>0.0001) didDrag = true;
      m.x = nx; m.y = ny;
      draw();
      return;
    }

    if(isPanning){
      const dx = sx - panStart.x;
      const dy = sy - panStart.y;
      if(Math.abs(dx)>2 || Math.abs(dy)>2) didDrag = true;
      view.offsetX = viewStart.ox + dx;
      view.offsetY = viewStart.oy + dy;
      clampViewToBounds();
      draw();
      return;
    }

    // hover overlay (user) - mouse only
    if(!state.ui.admin){
      const hit = findMarkerAtScreen(sx,sy);
      if(hit && hit.id !== lastHoverMarkerId && !hoverPinned){
        lastHoverMarkerId = hit.id;
        showHover(hit, sx, sy);
      }else if(!hit && !hoverPinned){
        hideHover();
      }
    }
  });

  window.addEventListener("mouseup", () => {
    if(draggingMarkerId){
      saveState();
      draggingMarkerId = "";
      draw();
      updateCounts();
    }
    isPanning = false;
  });

  canvas.addEventListener("click", (evt) => {
    // prevent click after drag
    if(didDrag) return;

    const {x:sx,y:sy} = getPointerPos(evt);
    const hit = findMarkerAtScreen(sx,sy);

    if(!state.ui.admin){
      // click empty -> unpin overlay
      if(!hit){
        hoverPinned = false;
        state.ui.pinnedOverlayMarkerId = "";
        saveState();
        hideHover();
        return;
      }
    }
  });

  canvas.addEventListener("dblclick", (evt) => {
    // user: pin overlay on label hover area 느낌
    if(state.ui.admin) return;
    const {x:sx,y:sy} = getPointerPos(evt);
    const hit = findMarkerAtScreen(sx,sy);
    if(hit){
      hoverPinned = true;
      state.ui.pinnedOverlayMarkerId = hit.id;
      saveState();
      showHover(hit, sx, sy);
    }
  });

  canvas.addEventListener("wheel", (evt) => {
    evt.preventDefault();
    const {x:sx,y:sy} = getPointerPos(evt);
    const before = screenToWorld(sx,sy);

    const delta = -evt.deltaY;
    const factor = delta > 0 ? 1.08 : 0.92;
    view.zoom = clamp(view.zoom * factor, MIN_ZOOM, MAX_ZOOM);

    const after = screenToWorld(sx,sy);
    view.offsetX += (after.x - before.x) * view.zoom;
    view.offsetY += (after.y - before.y) * view.zoom;

    clampViewToBounds();
    draw();
  }, {passive:false});

  // ---------- buttons ----------
  resetDimBtn.addEventListener("click", () => {
    state.ui.dimmedMarkerIds = [];
    saveState();
    draw();
    updateCounts();
  });

  brandBtn.addEventListener("click", () => {
    // (index) just toggle help maybe
    openHelp();
  });

  function openHelp(){
    helpModal.style.display = "flex";
  }
  function closeHelp(){
    helpModal.style.display = "none";
  }
  openHelpBtn.addEventListener("click", openHelp);
  closeHelpBtn.addEventListener("click", closeHelp);
  helpModal.addEventListener("click", (e) => {
    if(e.target === helpModal) closeHelp();
  });

  // ---------- change handlers ----------
  gameSelect.addEventListener("change", () => {
    state.ui.gameId = gameSelect.value;
    state.ui.pageId = currentPages()[0]?.id || "";
    state.ui.selectedMarkerId = "";
    state.ui.pinnedOverlayMarkerId = "";
    saveState();
    rebuildPageList();
    renderHeaderLabels();
    loadMapImage();
    fitToMap();
    draw();
  });

  // ---------- start ----------
  rebuildGameSelect();
  rebuildPageList();
  rebuildCategoryPills();
  renderHeaderLabels();
  updateCounts();

  loadMapImage().then(() => {
    resizeCanvas();
    fitToMap();
    draw();
  });

  window.addEventListener("resize", () => {
    resizeCanvas();
    clampViewToBounds();
    draw();
  });

})();
</script>

</body>
</html>
