<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAPMODE (index)</title>

  <style>
    :root{
      color-scheme: dark;
      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 14px;

      --topSlotW: 150px;
      --topSlotH: 38px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 800px at 15% 10%, rgba(124,196,255,.14), transparent 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(167,139,250,.14), transparent 55%),
        radial-gradient(1000px 900px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), #050812 70%);
      color: var(--text);
    }
    a{ color: var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      position:sticky;
      top:0;
      z-index:10;
      background: rgba(6,10,18,.72);
      border-bottom: 1px solid rgba(31,42,58,.9);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
    }

    button, input, select, textarea{
      background: rgba(16,24,38,.65);
      border: 1px solid rgba(39,52,74,.9);
      color: var(--text);
      border-radius: var(--r14);
      padding:9px 11px;
      font-size:14px;
      outline:none;
      transition: transform .08s ease, border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    button{ cursor:pointer; font-weight:800; }
    button:hover{ border-color: rgba(124,196,255,.55); box-shadow: 0 0 0 3px rgba(124,196,255,.12); }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; box-shadow:none; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(39,52,74,.9);
      border-radius:999px;
      background: rgba(14,22,38,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.6);
    }
    .muted{ color: var(--muted); font-size:12px; }
    .k{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }

    .wrap{
      display:grid;
      grid-template-columns: 380px 1fr 380px;
      height: calc(100vh - 56px);
    }
    .panel{
      background: rgba(8,12,20,.55);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      overflow:auto;
      padding:14px;
    }
    .panel.left{ border-right:1px solid rgba(31,42,58,.85); }
    .panel.right{ border-left:1px solid rgba(31,42,58,.85); }

    .center{ position:relative; overflow:hidden; }
    #canvas{
      width:100%;
      height:100%;
      display:block;
      background:#0b0f14;

      /* ✅ 드래그/확대 기본 동작 차단 */
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none;

      cursor:grab;
    }
    #canvas:active{ cursor:grabbing; }

    .section{
      border:1px solid rgba(31,42,58,.9);
      border-radius: var(--r18);
      padding:14px;
      margin-bottom:12px;
      background: linear-gradient(180deg, rgba(14,22,38,.72), rgba(10,16,28,.58));
      box-shadow: var(--shadow2);
    }
    .section h3{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.3px;
      color: rgba(231,238,248,.92);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .hr{ height:1px; background: rgba(31,42,58,.9); margin:12px 0; }

    .catGrid{ display:flex; flex-wrap:wrap; gap:8px; }
    .catBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(8,12,20,.55);
      font-size:12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .catDot{
      width:10px; height:10px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.9);
      display:inline-block;
    }
    .catBtn.active{
      border-color: rgba(124,196,255,.9);
      box-shadow: 0 0 0 3px rgba(124,196,255,.14);
    }

    .pageBtn{
      width:100%;
      padding:12px 12px;
      border-radius: var(--r16);
      border: 2px solid rgba(124,196,255,.40);
      background: rgba(10,18,30,.45);
      box-shadow: 0 0 0 4px rgba(124,196,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      text-align:left;
    }
    .pageBtn:hover{ border-color: rgba(124,196,255,.75); box-shadow: 0 0 0 4px rgba(124,196,255,.12); }
    .pageBtn.active{ border-color: rgba(57,217,138,.85); box-shadow: 0 0 0 4px rgba(57,217,138,.12); }
    .pageBtn .name{
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .linkBox{
      padding:12px 12px;
      border:1px solid rgba(39,52,74,.9);
      border-radius: var(--r16);
      background: rgba(8,12,20,.55);
      word-break:break-all;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
    }

    .resetDanger{
      width:100%;
      border: 2px solid rgba(255,93,93,.92) !important;
      background: rgba(26,10,12,.45) !important;
      box-shadow: 0 0 0 4px rgba(255,93,93,.10);
    }

    #hoverOverlay{
      position:absolute;
      display:none;
      z-index:50;
      background: rgba(10,16,28,.78);
      border: 1px solid rgba(124,196,255,.18);
      border-radius: var(--r16);
      padding:10px 12px;
      max-width:min(420px, 84vw);
      box-shadow: var(--shadow);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      pointer-events:auto;
    }
    #hoverOverlay .memoLabel{ font-size:12px; color: var(--muted); margin-bottom:6px; font-weight:800; }
    #hoverOverlay textarea{
      width:100%;
      resize:none;
      line-height:1.35;
      padding:10px 10px;
      border-radius:12px;
      margin-bottom:10px;
      font-size:13px;
    }
    #hoverOverlay textarea[readonly]{ opacity:.95; }
    #hoverOverlay .yt{ font-size:14px; font-weight:900; }

    .topSlots{ display:flex; align-items:center; gap:10px; }
    .topSlot{
      width: var(--topSlotW);
      height: var(--topSlotH);
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 14px;
      border:1px solid rgba(39,52,74,.9);
      background: rgba(14,22,38,.55);
      overflow:hidden;
      position:relative;
      flex: 0 0 auto;
    }
    #logoSlot{ padding:0; border:0; }
    #logoImg{ width:100%; height:100%; object-fit:contain; display:block; padding:4px; }

    @media (max-width:1100px){
      .wrap{ grid-template-columns: 1fr; height:auto; }
      .panel.left{ border-right:none; border-bottom:1px solid rgba(31,42,58,.85); }
      .panel.right{ border-left:none; border-top:1px solid rgba(31,42,58,.85); }
      #canvas{ height:55vh; }
    }
  </style>
</head>

<body>
  <header>
    <div class="topSlots">
      <div class="topSlot" id="logoSlot" title="로고">
        <img id="logoImg" alt="logo" />
      </div>

      <div class="topSlot" title="현재 게임">
        <div style="width:100%; display:flex; align-items:center; justify-content:center; font-weight:900;">
          <span id="gameTitleText">Map Demo</span>
        </div>
      </div>
    </div>

    <span class="pill" style="margin-left:auto;">
      <span class="badge">USER</span>
      <span class="muted">index</span>
    </span>
  </header>

  <div class="wrap">
    <aside class="panel left">
      <div class="section">
        <h3>페이지 <span class="badge" id="pageBadge" style="margin-left:auto;">-</span></h3>
        <div id="pageList" style="display:flex; flex-direction:column; gap:10px;"></div>
      </div>
    </aside>

    <div class="center" id="centerStage">
      <canvas id="canvas"></canvas>

      <div id="hoverOverlay">
        <div class="memoLabel">메모</div>
        <textarea id="hoverMemo" rows="3" readonly></textarea>
        <div class="yt" id="hoverYt">-</div>
      </div>
    </div>

    <aside class="panel right">
      <div class="section">
        <h3>카테고리</h3>
        <div class="catGrid" id="categoryBar"></div>
        <div class="muted" id="countInfo" style="margin-top:10px;">-</div>
      </div>

      <div class="section">
        <button id="resetDimBtn" class="resetDanger">마커 초기화</button>
        <div class="muted" style="margin-top:10px; line-height:1.4;">
          • 마커 클릭: 불투명 토글<br/>
          • 좌클릭 드래그: 지도 이동(패닝)<br/>
          • 휠: 확대/축소
        </div>
      </div>

      <div class="section">
        <h3 id="selectedHeader">선택한 마커</h3>
        <div class="hr"></div>
        <div class="muted">링크</div>
        <div id="youtubeBox" class="linkBox" style="margin-top:8px;">-</div>
      </div>
    </aside>
  </div>

  <script>
    // ====== index 전용: state.json 경로 통일 ======
    const REMOTE_STATE_URL = new URL("./data/state.json", location.href).toString();
    const REMOTE_SYNC_INTERVAL_MS = 15000;

    // 로고(원하면 state.json과 별도로 localStorage에서 유지 가능)
    const DEFAULT_LOGO_URL = new URL("./assets/logo/MAPMODELOGO2.png", location.href).toString();
    const LOGO_KEY = "mm_logo_url_v1";

    // local state key
    const LS_KEY = "imgmap_multi_v700";

    // helpers
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const safeParse = (s,f)=>{ try{return JSON.parse(s);}catch{return f;} };
    const escapeHtml = (s)=>String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    const isValidUrl = (u)=>{ try{ new URL(u, location.href); return true; }catch{ return false; } };

    // ====== state load ======
    const defaultState = { ui:{ admin:false, selectedCategory:"", selectedMarkerId:"", dimmedMarkerIds:[] }, currentGameId:"", currentPageId:"", games:[] };
    const state = (() => {
      const loaded = safeParse(localStorage.getItem(LS_KEY)||"", null);
      if(loaded && Array.isArray(loaded.games)) return loaded;
      return structuredClone(defaultState);
    })();

    // ====== DOM ======
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const centerStage = document.getElementById("centerStage");

    const $logoImg = document.getElementById("logoImg");
    const gameTitleText = document.getElementById("gameTitleText");

    const pageBadge = document.getElementById("pageBadge");
    const pageList = document.getElementById("pageList");

    const categoryBar = document.getElementById("categoryBar");
    const countInfo = document.getElementById("countInfo");

    const selectedHeader = document.getElementById("selectedHeader");
    const youtubeBox = document.getElementById("youtubeBox");

    const hoverOverlay = document.getElementById("hoverOverlay");
    const hoverMemo = document.getElementById("hoverMemo");
    const hoverYt = document.getElementById("hoverYt");

    const resetDimBtn = document.getElementById("resetDimBtn");

    // ====== view ======
    const view = { scale:1, minScale:0.05, maxScale:10, offsetX:0, offsetY:0 };
    const DEFAULT_MARKER_RADIUS_PX = 10;

    function saveState(){
      state._updatedAt = Date.now();
      state._updatedAtISO = new Date().toISOString();
      try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){ console.warn(e); }
    }

    function getGameById(id){ return (state.games||[]).find(g=>g.id===id) || null; }
    function getCurrentGame(){
      if(!Array.isArray(state.games) || state.games.length===0) return null;
      if(!state.currentGameId) state.currentGameId = state.games[0].id;
      return getGameById(state.currentGameId) || state.games[0];
    }
    function getPageById(game, pid){ return (game.pages||[]).find(p=>p.id===pid) || null; }
    function getCurrentPage(){
      const g = getCurrentGame();
      if(!g) return null;
      if(!state.currentPageId) state.currentPageId = g.pages[0]?.id || "";
      return getPageById(g, state.currentPageId) || g.pages[0] || null;
    }
    function currentCategories(){ return getCurrentGame()?.categories || []; }
    function currentMarkers(){ return getCurrentPage()?.markers || []; }
    function currentLinks(){ return getCurrentPage()?.links || []; }
    function currentMap(){ return getCurrentPage()?.map || null; }

    function getCategoryColor(name){
      const c = currentCategories().find(x=>x.name===name);
      return c?.color || "#e6edf3";
    }
    function getMarkerColor(m){
      const ov = (m.colorOverride||"").trim();
      return ov ? ov : getCategoryColor(m.category);
    }
    function getMarkerLabel(m){
      const t = (m.title||"").trim();
      return t ? t : ((m.category||"").trim() || "marker");
    }
    function getUserYoutubeDisplay(m){
      return (m.youtubeLabel||"").trim() || (m.title||"").trim() || "유튜브";
    }

    // ====== logo ======
    function loadLogo(){
      let raw = "";
      try{ raw = (localStorage.getItem(LOGO_KEY)||"").trim(); }catch{}
      const url = raw || DEFAULT_LOGO_URL;
      $logoImg.src = url;
    }

    // ====== map image ======
    const mapImg = new Image();
    mapImg.crossOrigin = "anonymous";
    let mapImgReady = false;

    async function loadMapImageForCurrentPage(){
      const mp = currentMap();
      if(!mp){ mapImgReady=false; draw(); return; }
      let url = (mp.imageUrl||"").trim();
      if(!url){
        // fallback: 저장된 게 없으면 그냥 빈 배경으로
        mapImgReady=false;
        draw();
        return;
      }
      const abs = new URL(url, location.href).toString();
      mapImg.onload = () => {
        mapImgReady = true;
        mp.width = mapImg.naturalWidth || mp.width || mapImg.width;
        mp.height = mapImg.naturalHeight || mp.height || mapImg.height;
        resetView();
        draw();
      };
      mapImg.onerror = () => { mapImgReady=false; draw(); };
      mapImg.src = abs + (abs.includes("?") ? "&" : "?") + "v=" + Date.now();
    }

    function clampViewToBounds(){
      const rect = canvas.getBoundingClientRect();
      const cw = rect.width, ch = rect.height;
      const mp = currentMap();
      if(!mp){ return; }

      const mw = (mp.width||1) * view.scale;
      const mh = (mp.height||1) * view.scale;

      if(mw <= cw) view.offsetX = (cw - mw) / 2;
      else view.offsetX = clamp(view.offsetX, cw - mw, 0);

      if(mh <= ch) view.offsetY = (ch - mh) / 2;
      else view.offsetY = clamp(view.offsetY, ch - mh, 0);
    }

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      clampViewToBounds();
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    function resetView(){
      const mp = currentMap();
      if(!mp){ return; }
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      const s = Math.min(w / (mp.width||1), h / (mp.height||1)) * 0.95;
      view.scale = clamp(s, view.minScale, view.maxScale);
      view.offsetX = (w - (mp.width||1) * view.scale) / 2;
      view.offsetY = (h - (mp.height||1) * view.scale) / 2;
      clampViewToBounds();
    }

    function worldToScreen(wx, wy){ return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY }; }
    function screenToWorld(sx, sy){ return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale }; }

    // ====== UI build ======
    function rebuildCategoryBar(){
      categoryBar.innerHTML = "";
      categoryBar.appendChild(makeCatButton("전체","", "#223042"));
      for(const c of currentCategories()){
        categoryBar.appendChild(makeCatButton(c.name, c.name, c.color || "#e6edf3"));
      }
    }
    function makeCatButton(label, value, color){
      const btn = document.createElement("button");
      btn.className = "catBtn" + (state.ui.selectedCategory===value ? " active" : "");
      const dot = document.createElement("span");
      dot.className="catDot";
      dot.style.background = color;
      btn.appendChild(dot);
      const t = document.createElement("span");
      t.textContent = label;
      btn.appendChild(t);

      btn.addEventListener("click", ()=>{
        state.ui.selectedCategory = value;
        saveState();
        rebuildCategoryBar();
        draw();
      });
      return btn;
    }
    function rebuildPageList(){
      const g = getCurrentGame();
      const p = getCurrentPage();
      pageList.innerHTML = "";
      if(!g || !p){
        pageBadge.textContent = "state 없음";
        return;
      }
      pageBadge.textContent = `${g.name} / ${p.name}`;
      gameTitleText.textContent = g.name || "Map Demo";

      for(const pg of (g.pages||[])){
        const btn = document.createElement("button");
        btn.className = "pageBtn" + (pg.id===p.id ? " active" : "");
        btn.innerHTML = `<div class="name">${escapeHtml(pg.name||"Page")}</div>`;
        btn.addEventListener("click", ()=>{
          state.currentPageId = pg.id;
          state.ui.selectedMarkerId = "";
          state.ui.dimmedMarkerIds = [];
          saveState();
          rebuildPageList();
          rebuildCategoryBar();
          loadMapImageForCurrentPage();
          draw();
        });
        pageList.appendChild(btn);
      }
    }

    function renderSelectedPanel(){
      const m = currentMarkers().find(x=>x.id===state.ui.selectedMarkerId);
      if(!m){
        selectedHeader.textContent = "선택한 마커";
        youtubeBox.textContent = "-";
        return;
      }
      const name = (m.title||"").trim() || "(이름 없음)";
      selectedHeader.textContent = `선택한 마커: ${name}`;
      const url = (m.youtubeUrl||"").trim();
      const display = getUserYoutubeDisplay(m);
      if(url && isValidUrl(url)){
        youtubeBox.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(display)}</a>`;
      }else{
        youtubeBox.textContent = display || "-";
      }
    }

    // ====== hit test ======
    function getPointerPos(evt){
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }
    function markerWorldPos(m){
      const mp = currentMap();
      return { wx: (m.x||0) * (mp?.width||1), wy: (m.y||0) * (mp?.height||1) };
    }
    function findMarkerAtScreen(sx, sy){
      const mp = currentMap();
      if(!mp) return null;

      const cat = state.ui.selectedCategory || "";
      const list = cat ? currentMarkers().filter(mm=>mm.category===cat) : currentMarkers();

      for(let i=list.length-1;i>=0;i--){
        const m = list[i];
        const { wx, wy } = markerWorldPos(m);
        const p = worldToScreen(wx, wy);
        const r = (typeof m.radiusPx==="number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX) * view.scale;
        const dx = sx - p.x, dy = sy - p.y;
        if(dx*dx + dy*dy <= r*r) return m;
      }
      return null;
    }

    // ====== overlay ======
    let overlayPinned = false;
    function hideHoverOverlay(force=false){
      if(!force && overlayPinned) return;
      hoverOverlay.style.display = "none";
    }
    function showOverlayForMarker(m, clientX, clientY, pinned=false){
      overlayPinned = pinned;
      hoverMemo.value = m.memo || "";
      const url = (m.youtubeUrl||"").trim();
      if(url && isValidUrl(url)){
        hoverYt.innerHTML = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(getUserYoutubeDisplay(m))}</a>`;
      }else{
        hoverYt.innerHTML = `<span class="muted">유튜브 없음</span>`;
      }

      const stageRect = centerStage.getBoundingClientRect();
      let x = clientX - stageRect.left + 16;
      let y = clientY - stageRect.top + 16;
      hoverOverlay.style.left = x + "px";
      hoverOverlay.style.top = y + "px";
      hoverOverlay.style.display = "block";

      // clamp to stage
      const pad=10;
      const r = hoverOverlay.getBoundingClientRect();
      const maxX = stageRect.width - r.width - pad;
      const maxY = stageRect.height - r.height - pad;
      x = clamp(x, pad, Math.max(pad, maxX));
      y = clamp(y, pad, Math.max(pad, maxY));
      hoverOverlay.style.left = x + "px";
      hoverOverlay.style.top = y + "px";
    }

    // ====== zoom ======
    canvas.addEventListener("wheel", (evt)=>{
      evt.preventDefault();
      const mp = currentMap();
      if(!mp) return;

      const { x:sx, y:sy } = getPointerPos(evt);
      const before = screenToWorld(sx, sy);

      const zoomFactor = Math.exp((-evt.deltaY) * 0.0015);
      view.scale = clamp(view.scale * zoomFactor, view.minScale, view.maxScale);

      const after = screenToWorld(sx, sy);
      view.offsetX += (after.x - before.x) * view.scale;
      view.offsetY += (after.y - before.y) * view.scale;

      clampViewToBounds();
      draw();
    }, { passive:false });

    // ====== ✅ 드래그 패닝: Pointer Events + Capture (핵심) ======
    let dragActive = false;
    let dragMoved = false;
    let downScreen = {x:0,y:0};
    let viewStart = {ox:0, oy:0};
    let downMarkerId = "";
    const DRAG_THRESHOLD = 3;

    canvas.addEventListener("pointerdown", (evt)=>{
      if(evt.button !== 0) return; // 좌클릭만
      evt.preventDefault();
      canvas.setPointerCapture(evt.pointerId); // ✅ 드래그 중 이벤트 놓치지 않음

      const {x:sx,y:sy} = getPointerPos(evt);
      dragActive = true;
      dragMoved = false;
      downScreen = {x:sx,y:sy};
      viewStart = {ox:view.offsetX, oy:view.offsetY};

      const m = findMarkerAtScreen(sx, sy);
      downMarkerId = m ? m.id : "";

      // 선택 패널은 down 시점에 갱신(기존 동작 유지)
      if(m){
        state.ui.selectedMarkerId = m.id;
        renderSelectedPanel();
      }
    });

    canvas.addEventListener("pointermove", (evt)=>{
      if(!dragActive) {
        // hover (드래그 아닐 때)
        if(!overlayPinned){
          const {x:sx,y:sy} = getPointerPos(evt);
          const m = findMarkerAtScreen(sx, sy);
          if(m) showOverlayForMarker(m, evt.clientX, evt.clientY, false);
          else hideHoverOverlay();
        }
        return;
      }

      evt.preventDefault();
      const {x:sx,y:sy} = getPointerPos(evt);
      const dx = sx - downScreen.x;
      const dy = sy - downScreen.y;

      if(!dragMoved && (Math.abs(dx)>DRAG_THRESHOLD || Math.abs(dy)>DRAG_THRESHOLD)){
        dragMoved = true;
        if(!overlayPinned) hideHoverOverlay(true);
      }

      // ✅ moved 여부와 상관없이 "누른 채 이동"이면 항상 패닝
      view.offsetX = viewStart.ox + dx;
      view.offsetY = viewStart.oy + dy;
      clampViewToBounds();
      draw();
    });

    function endDrag(){
      dragActive = false;
      dragMoved = false;
      downMarkerId = "";
    }

    canvas.addEventListener("pointerup", (evt)=>{
      if(!dragActive) return;
      evt.preventDefault();

      // 클릭(드래그X)인 경우에만 마커 불투명 토글
      if(!dragMoved && downMarkerId){
        const arr = Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : [];
        const idx = arr.indexOf(downMarkerId);
        if(idx>=0) arr.splice(idx,1);
        else arr.push(downMarkerId);
        state.ui.dimmedMarkerIds = arr;
        saveState();
        draw();
      }

      endDrag();
    });

    canvas.addEventListener("pointercancel", endDrag);
    canvas.addEventListener("lostpointercapture", endDrag);

    // 클릭으로 오버레이 고정/해제
    canvas.addEventListener("click", (evt)=>{
      // dragMoved 직후 click은 브라우저마다 섞여 나올 수 있어 방지
      if(dragActive || dragMoved) return;
      const {x:sx,y:sy} = getPointerPos(evt);
      const m = findMarkerAtScreen(sx, sy);
      if(m){
        showOverlayForMarker(m, evt.clientX, evt.clientY, true);
      }else{
        overlayPinned = false;
        hideHoverOverlay(true);
      }
    });

    // ====== reset dim ======
    resetDimBtn.addEventListener("click", ()=>{
      state.ui.dimmedMarkerIds = [];
      saveState();
      draw();
    });

    // ====== draw ======
    function drawBackground(){
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);
      ctx.fillStyle = "#070b12";
      ctx.fillRect(0,0,rect.width,rect.height);
    }

    function draw(){
      const mp = currentMap();
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      drawBackground();
      if(!mp){
        countInfo.textContent = "state.json을 불러오지 못했거나 페이지가 없습니다.";
        return;
      }

      // 지도
      ctx.save();
      ctx.translate(view.offsetX, view.offsetY);
      ctx.scale(view.scale, view.scale);

      if(mapImgReady){
        ctx.drawImage(mapImg, 0, 0, mp.width, mp.height);
      }else{
        ctx.fillStyle = "#0d131c";
        ctx.fillRect(0,0,mp.width, mp.height);
      }

      const cat = state.ui.selectedCategory || "";
      const visibleMarkers = cat ? currentMarkers().filter(mm=>mm.category===cat) : currentMarkers();

      // ✅ 선(links): "항상" 그린다 (필터로 지워지지 않게)
      // (단, 링크 양 끝 마커가 존재할 때만)
      const idToMarker = new Map(currentMarkers().map(m=>[m.id,m]));
      const links = currentLinks();

      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.lineWidth = 2 / view.scale;
      ctx.strokeStyle = "rgba(124,196,255,.75)";
      for(const ln of links){
        const a = idToMarker.get(ln.a || ln.from || ln.src);
        const b = idToMarker.get(ln.b || ln.to || ln.dst);
        if(!a || !b) continue;
        const ax = (a.x||0) * mp.width, ay = (a.y||0) * mp.height;
        const bx = (b.x||0) * mp.width, by = (b.y||0) * mp.height;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      }
      ctx.restore();

      // 마커
      const dimSet = new Set(Array.isArray(state.ui.dimmedMarkerIds) ? state.ui.dimmedMarkerIds : []);
      for(const m of visibleMarkers){
        const wx = (m.x||0) * mp.width;
        const wy = (m.y||0) * mp.height;
        const rPx = (typeof m.radiusPx==="number" ? m.radiusPx : DEFAULT_MARKER_RADIUS_PX);
        const r = rPx / view.scale;

        const isDim = dimSet.has(m.id);
        const alpha = isDim ? 0.30 : 1.0;

        // circle
        ctx.save();
        ctx.translate(wx, wy);
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.fillStyle = getMarkerColor(m);
        ctx.arc(0,0,r,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#0b0f14";
        ctx.lineWidth = 2 / view.scale;
        ctx.stroke();

        // label (항상 진하게)
        ctx.globalAlpha = 1.0;
        const label = getMarkerLabel(m);
        const fs = (m.labelSizePx ? m.labelSizePx : 16) / view.scale;
        ctx.font = `900 ${fs}px system-ui`;
        ctx.fillStyle = "#e6edf3";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(label, r + (10 / view.scale), 0);

        ctx.restore();
      }

      ctx.restore();

      countInfo.textContent = `표시 마커: ${visibleMarkers.length} / 전체: ${currentMarkers().length} · 링크: ${currentLinks().length}`;
      renderSelectedPanel();
    }

    // ====== remote sync ======
    async function tryFetchRemoteState(){
      try{
        const url = REMOTE_STATE_URL + (REMOTE_STATE_URL.includes("?") ? "&" : "?") + "v=" + Date.now();
        const res = await fetch(url, { cache:"no-store" });
        if(!res.ok) return null;
        const j = await res.json();
        if(!j || !Array.isArray(j.games)) return null;
        return j;
      }catch{ return null; }
    }

    function acceptRemoteState(remote){
      // index는 무조건 user
      remote.ui = remote.ui || {};
      remote.ui.admin = false;

      // dim은 로컬 유지(원하면 여기서 remote로 덮어도 됨)
      const keepDim = Array.isArray(state.ui?.dimmedMarkerIds) ? [...state.ui.dimmedMarkerIds] : [];

      // state 덮기
      state.games = remote.games;
      state.currentGameId = remote.currentGameId || state.games[0]?.id || "";
      const g = getCurrentGame();
      state.currentPageId = remote.currentPageId || g?.pages?.[0]?.id || "";

      state.ui.selectedCategory = state.ui.selectedCategory || "";
      state.ui.selectedMarkerId = "";
      state.ui.dimmedMarkerIds = keepDim;

      state._updatedAt = Number(remote._updatedAt || Date.now());
      state._updatedAtISO = remote._updatedAtISO || new Date(state._updatedAt).toISOString();

      saveState();
    }

    async function syncFromRemoteIfNewer(){
      const remote = await tryFetchRemoteState();
      if(!remote) return;

      const remoteAt = Number(remote._updatedAt || 0);
      const localAt = Number(state._updatedAt || 0);
      if(remoteAt && remoteAt <= localAt) return;

      acceptRemoteState(remote);
      rebuildPageList();
      rebuildCategoryBar();
      await loadMapImageForCurrentPage();
      draw();
    }

    // ====== init ======
    async function init(){
      loadLogo();

      resizeCanvas();

      // 최초 로컬 렌더
      rebuildPageList();
      rebuildCategoryBar();
      await loadMapImageForCurrentPage();
      resetView();
      draw();

      // remote sync
      await syncFromRemoteIfNewer();
      setInterval(syncFromRemoteIfNewer, REMOTE_SYNC_INTERVAL_MS);

      document.addEventListener("visibilitychange", ()=>{
        if(document.visibilityState==="visible") syncFromRemoteIfNewer();
      });
    }
    init();
  </script>
</body>
</html>
