<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Interactive Multi-Map Demo v7.0.0 (Index)</title>

  <style>
    :root{
      color-scheme: dark;

      --bg:#070b12;
      --panel:#0b1220cc;
      --card:#0e1626cc;
      --stroke:#1f2a3a;
      --stroke2:#27344a;
      --text:#e7eef8;
      --muted:#9fb0c6;
      --accent:#7cc4ff;
      --danger:#ff5d5d;
      --ok:#39d98a;
      --warn:#ffd60a;

      --r14:14px;
      --r16:16px;
      --r18:18px;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 24px rgba(0,0,0,.35);
      --blur: 10px;

      --toolW: 360px;
      --toolMinW: 300px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "Malgun Gothic", Arial, sans-serif;

      /* (3) ëª¨ë°”ì¼ì—ì„œ ê°€ë¡œë¡œ ë°€ë¦¬ëŠ” ë¬¸ì œ ë°©ì§€ */
      overflow-x:hidden;
      overscroll-behavior: none;
    }

    /* ì „ì²´ ë ˆì´ì•„ì›ƒ */
    .app{
      height:100%;
      display:flex;
      gap:0;
      width:100vw; /* ê°€ë¡œ ìŠ¤í¬ë¡¤ ë°©ì§€ í•µì‹¬ */
      overflow:hidden;
    }

    /* ì§€ë„ ì˜ì—­ */
    .stage{
      position:relative;
      flex:1 1 auto;
      min-width:0;
      background: radial-gradient(1200px 800px at 30% 20%, rgba(124,196,255,.08), transparent 60%),
                  radial-gradient(900px 600px at 80% 60%, rgba(57,217,138,.06), transparent 60%),
                  var(--bg);
      border-right:1px solid var(--stroke);
      overflow:hidden;
      touch-action: none; /* ëª¨ë°”ì¼ì—ì„œ ë“œë˜ê·¸/ì¤Œ ì œìŠ¤ì²˜ ì•ˆì •í™” */
    }

    /* íˆ´ íŒ¨ë„ */
    .tools{
      width: var(--toolW);
      max-width: 48vw;
      min-width: var(--toolMinW);
      background: var(--panel);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      border-left:1px solid var(--stroke);
      display:flex;
      flex-direction:column;
      overflow:hidden; /* íŒ¨ë„ ë‚´ë¶€ë§Œ ìŠ¤í¬ë¡¤ */
    }

    .toolsHeader{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--stroke);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .brand{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    .brandTitle{
      font-weight:800;
      letter-spacing:.2px;
      font-size:16px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brandSub{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .btn{
      appearance:none;
      border:1px solid var(--stroke2);
      background: rgba(14,22,38,.55);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      box-shadow: var(--shadow2);
      transition: transform .06s ease, border-color .15s ease, background .15s ease;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(124,196,255,.35); }
    .btn:active{ transform: translateY(1px); }

    .btnDanger{
      border:2px solid rgba(255,93,93,.85);
      background: rgba(255,93,93,.08);
    }

    .toolsBody{
      padding:14px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .card{
      background: var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px;
      box-shadow: var(--shadow2);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .row > *{ flex: 1 1 auto; min-width: 120px; }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    .select{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--stroke2);
      background: rgba(7,11,18,.55);
      color:var(--text);
      outline:none;
    }

    /* ìº”ë²„ìŠ¤ */
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    /* ë§ˆì»¤ í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´(í…ìŠ¤íŠ¸ í˜¸ë²„/í´ë¦­ìš©) */
    .overlay{
      position:absolute;
      inset:0;
      pointer-events:none; /* ê¸°ë³¸ì€ í†µê³¼ */
    }

    .markerLabel{
      position:absolute;
      transform: translate(-50%, -100%);
      pointer-events:auto; /* í…ìŠ¤íŠ¸ëŠ” ì´ë²¤íŠ¸ ë°›ê¸° */
      user-select:none;
      white-space:nowrap;
      font-weight:700;
      font-size:14px;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
      color: var(--text);
      padding:2px 6px;
      border-radius:10px;
      background: rgba(7,11,18,.25);
      border:1px solid rgba(39,52,74,.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .markerLabel:hover{
      border-color: rgba(124,196,255,.45);
      background: rgba(124,196,255,.10);
    }

    /* (2) ë©”ëª¨ì¥(íˆ´íŒ) */
    .memoTip{
      position:absolute;
      left:50%;
      top:-8px;
      transform: translate(-50%, -100%);
      width: min(320px, 70vw);
      max-width: 360px;
      background: rgba(14,22,38,.92);
      border:1px solid rgba(39,52,74,.7);
      border-radius:14px;
      box-shadow: 0 14px 45px rgba(0,0,0,.55);
      padding:10px 10px 9px;
      color: var(--text);
      pointer-events:auto;
      display:none;
    }
    .memoTip.show{ display:block; }
    .memoTitle{
      font-size:12px;
      font-weight:900;
      color: var(--accent);
      margin:0 0 6px;
      letter-spacing:.2px;
    }
    .memoText{
      font-size:13px;
      line-height:1.45;
      color: var(--text);
      white-space:pre-wrap;
      margin:0;
    }
    .memoMeta{
      margin-top:8px;
      font-size:12px;
      color: var(--muted);
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(39,52,74,.6);
      background: rgba(7,11,18,.35);
    }
    .a{
      color: var(--accent);
      text-decoration:none;
      font-weight:800;
    }
    .a:hover{ text-decoration:underline; }

    /* ëª¨ë°”ì¼ ë ˆì´ì•„ì›ƒ ê³ ì • (3) */
    @media (max-width: 980px){
      .app{
        flex-direction:column;
      }
      .stage{
        flex: 1 1 auto;
        height: 62vh;
        border-right:none;
        border-bottom:1px solid var(--stroke);
      }
      .tools{
        width:100vw;           /* ê°€ë¡œë¡œ ë” ì›€ì§ì´ëŠ” ë¬¸ì œ ì°¨ë‹¨ */
        max-width:none;
        min-width:0;
        height: 38vh;          /* ì„¸ë¡œ ë¹„ìœ¨ ê³ ì • */
        border-left:none;
      }
      .toolsBody{
        padding-bottom: calc(14px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="stage" id="stage" aria-label="map stage">
      <canvas id="cv"></canvas>
      <div class="overlay" id="overlay"></div>
    </div>

    <aside class="tools" aria-label="tools panel">
      <div class="toolsHeader">
        <div class="brand">
          <div class="brandTitle" id="titleText">Interactive Map</div>
          <div class="brandSub" id="subText">index.html Â· ./data/state.json ë¡œë“œ</div>
        </div>
        <button class="btn btnDanger" id="btnResetOpacity" title="ë¶ˆíˆ¬ëª…í™”ëœ ë§ˆì»¤ë¥¼ ëª¨ë‘ ì›ë˜ëŒ€ë¡œ">ë§ˆì»¤ ì´ˆê¸°í™”</button>
      </div>

      <div class="toolsBody">
        <div class="card">
          <div class="row">
            <div style="min-width:180px;">
              <div class="hint" style="margin-bottom:8px;">í˜ì´ì§€(ì§€ë„) ì„ íƒ</div>
              <select class="select" id="pageSelect"></select>
            </div>
            <div style="min-width:180px;">
              <div class="hint" style="margin-bottom:8px;">ë³´ê¸°/ì¡°ì‘</div>
              <div class="row">
                <button class="btn" id="btnFit">í™”ë©´ë§ì¶¤</button>
                <button class="btn" id="btnZoomIn">+</button>
                <button class="btn" id="btnZoomOut">-</button>
              </div>
            </div>
          </div>
          <div class="hint" style="margin-top:10px;">
            - ë“œë˜ê·¸: ì§€ë„ ì´ë™ (ë§ˆìš°ìŠ¤ ì¢Œí´ë¦­ ìœ ì§€ ì´ë™ ê°€ëŠ¥)<br/>
            - íœ /í•€ì¹˜: ì¤Œ ì¸/ì•„ì›ƒ<br/>
            - ë§ˆì»¤(ì›) í´ë¦­: í•´ë‹¹ ë§ˆì»¤ ë¶ˆíˆ¬ëª… 30% í† ê¸€(í•œ ë²ˆ ë” í´ë¦­í•˜ë©´ ì›ë³µ)<br/>
            - ë§ˆì»¤ â€œí…ìŠ¤íŠ¸â€ì— ë§ˆìš°ìŠ¤: ë©”ëª¨/ë§í¬ íˆ´íŒ í‘œì‹œ<br/>
            - í…ìŠ¤íŠ¸ í´ë¦­: íˆ´íŒ ê³ ì •/í•´ì œ
          </div>
        </div>

        <div class="card">
          <div class="hint" style="margin-bottom:8px;">ìƒíƒœ ë¡œë”©</div>
          <div class="row">
            <button class="btn" id="btnReload">state.json ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <button class="btn" id="btnClearLocal">ë¡œì»¬ ìºì‹œ ì‚­ì œ</button>
          </div>
          <div class="hint" style="margin-top:10px;">
            (4) PC/ëª¨ë°”ì¼ ëª¨ë‘ ë™ì¼í•˜ê²Œ <b>./data/state.json</b>ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.<br/>
            state.json ë¡œë“œê°€ ì‹¤íŒ¨í•˜ë©´(404/êµ¬ì¡° ë¶ˆì¼ì¹˜ ë“±) í™”ë©´ì´ ì•„ì˜ˆ ì•ˆëœ¨ì§€ ì•Šë„ë¡ ê¸°ë³¸ ë°ì´í„°ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.
          </div>
        </div>

        <div class="card">
          <div class="hint">
            <b>ì¤‘ìš”:</b> â€œê¸°ì¡´ ì½”ë“œì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ê±´ë“¤ì§€ ë§ë¼â€ ì¡°ê±´ì„ ì •í™•íˆ ì§€í‚¤ë ¤ë©´,<br/>
            ë‹¹ì‹ ì´ ë§í•œ â€œì˜ˆì „ ì½”ë“œ(ì •ìƒ ë™ì‘í•˜ë˜ index)â€ ì „ì²´ê°€ í•„ìš”í•©ë‹ˆë‹¤.<br/>
            ì§€ê¸ˆì€ ê·¸ ì½”ë“œê°€ ëŒ€í™”ì— ì™„ì „íˆ ì—†ì–´ì„œ, ë™ì¼ UI/ë™ì‘ì„ 1:1ë¡œ ë³µì›í•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.<br/>
            ëŒ€ì‹ , ìš”ì²­í•œ 4ê°œ ê¸°ëŠ¥ì´ í™•ì‹¤íˆ ë™ì‘í•˜ëŠ” â€œìš´ì˜ ê°€ëŠ¥í•œ ì¸ë±ìŠ¤â€ë¥¼ ì œê³µí•œ ìƒíƒœì…ë‹ˆë‹¤.
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    /******************************************************************
     * (4) ìƒíƒœ íŒŒì¼ ê²½ë¡œ í†µì¼: ./data/state.json
     ******************************************************************/
    const REMOTE_STATE_URL = new URL("./data/state.json", location.href);

    /******************************************************************
     * ì•ˆì „í•œ ê¸°ë³¸ ë°ì´í„° (state.json ë¡œë“œ ì‹¤íŒ¨/êµ¬ì¡° ë¶ˆì¼ì¹˜ ì‹œë¼ë„ í™”ë©´ì´ ëœ¨ê²Œ)
     ******************************************************************/
    const FALLBACK_STATE = {
      version: "7.0.0",
      title: "Interactive Map",
      pages: [
        {
          id: "map-1",
          name: "1ë²ˆ ë§ˆì„",
          imageUrl: "./data/maps/map1.jpg", // ìˆìœ¼ë©´ í‘œì‹œë¨. ì—†ìœ¼ë©´ ê²€ì€ ë°°ê²½ì— ë§ˆì»¤ë§Œ í‘œì‹œ
          markers: [
            { id:"m1", x: 1200, y: 900,  label:"ìƒì ",  memo:"ì—¬ê¸´ ìƒì  ë©”ëª¨ ì˜ˆì‹œì…ë‹ˆë‹¤.\ní…ìŠ¤íŠ¸ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ë³´ì…ë‹ˆë‹¤.", linkTitle:"ìœ íŠœë¸Œ ë§í¬ ì œëª© ì˜ˆì‹œ", linkUrl:"https://youtube.com" },
            { id:"m2", x: 1600, y: 1100, label:"ë³´ìŠ¤",  memo:"ë³´ìŠ¤ ìœ„ì¹˜.\nì£¼ì˜: íŒ¨í„´ í™•ì¸!", linkTitle:"ê³µëµ ì˜ìƒ", linkUrl:"https://youtube.com" }
          ]
        }
      ]
    };

    const LS_KEY = "interactive_map_state_cache_v700_index";

    /******************************************************************
     * Canvas + Pan/Zoom ê¸°ë³¸ê¸°
     ******************************************************************/
    const stage = document.getElementById("stage");
    const canvas = document.getElementById("cv");
    const ctx = canvas.getContext("2d");
    const overlay = document.getElementById("overlay");

    const pageSelect = document.getElementById("pageSelect");
    const titleText = document.getElementById("titleText");

    const btnResetOpacity = document.getElementById("btnResetOpacity");
    const btnFit = document.getElementById("btnFit");
    const btnZoomIn = document.getElementById("btnZoomIn");
    const btnZoomOut = document.getElementById("btnZoomOut");
    const btnReload = document.getElementById("btnReload");
    const btnClearLocal = document.getElementById("btnClearLocal");

    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    let state = null;
    let currentPage = null;
    let img = new Image();
    img.decoding = "async";
    img.crossOrigin = "anonymous";

    // view transform
    let view = {
      scale: 1,
      minScale: 0.08,
      maxScale: 8,
      tx: 0,   // screen translation
      ty: 0
    };

    // drag
    let dragging = false;
    let dragStart = { x:0, y:0, tx:0, ty:0 };

    // marker opacity state
    // (1) í´ë¦­í•œ ë§ˆì»¤ë§Œ 30%ë¡œ í† ê¸€, ë‹¤ì‹œ í´ë¦­í•˜ë©´ í•´ì œ
    const dimmed = new Set(); // markerId

    // tooltip pin
    let pinnedLabelId = null;

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function resize(){
      const r = stage.getBoundingClientRect();
      canvas.width = Math.round(r.width * DPR);
      canvas.height = Math.round(r.height * DPR);
      canvas.style.width = r.width + "px";
      canvas.style.height = r.height + "px";
      draw();
      layoutOverlay();
    }

    window.addEventListener("resize", resize);

    function screenToWorld(sx, sy){
      // sx,sy are CSS pixels relative to stage
      const x = (sx - view.tx) / view.scale;
      const y = (sy - view.ty) / view.scale;
      return { x, y };
    }

    function worldToScreen(wx, wy){
      const x = wx * view.scale + view.tx;
      const y = wy * view.scale + view.ty;
      return { x, y };
    }

    function fitToScreen(){
      const r = stage.getBoundingClientRect();
      const iw = img && img.naturalWidth ? img.naturalWidth : 2400;
      const ih = img && img.naturalHeight ? img.naturalHeight : 1400;

      const pad = 40;
      const sx = (r.width - pad*2) / iw;
      const sy = (r.height - pad*2) / ih;
      const s = clamp(Math.min(sx, sy), view.minScale, view.maxScale);

      view.scale = s;
      // center
      view.tx = (r.width  - iw * s) / 2;
      view.ty = (r.height - ih * s) / 2;

      draw();
      layoutOverlay();
    }

    function zoomAt(factor, cx, cy){
      const before = screenToWorld(cx, cy);
      const nextScale = clamp(view.scale * factor, view.minScale, view.maxScale);
      view.scale = nextScale;
      const after = worldToScreen(before.x, before.y);
      // keep cursor point stable
      view.tx += (cx - after.x);
      view.ty += (cy - after.y);
      draw();
      layoutOverlay();
    }

    /******************************************************************
     * Render
     ******************************************************************/
    function clear(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function draw(){
      clear();

      // base
      ctx.setTransform(DPR,0,0,DPR,0,0);

      // world transform
      ctx.translate(view.tx, view.ty);
      ctx.scale(view.scale, view.scale);

      // draw image if available
      if (img && img.naturalWidth){
        ctx.drawImage(img, 0, 0);
      } else {
        // fallback grid
        ctx.fillStyle = "rgba(14,22,38,.35)";
        ctx.fillRect(0,0,2400,1400);
        ctx.strokeStyle = "rgba(39,52,74,.45)";
        ctx.lineWidth = 2;
        for(let x=0; x<=2400; x+=200){
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,1400); ctx.stroke();
        }
        for(let y=0; y<=1400; y+=200){
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(2400,y); ctx.stroke();
        }
      }

      // markers
      if (!currentPage) return;
      const markers = currentPage.markers || [];

      for (let i=0; i<markers.length; i++){
        const m = markers[i];
        drawMarker(m, i+1);
      }
    }

    function drawMarker(m, idx){
      const rBase = 18;
      const ring = 3;

      const isDim = dimmed.has(m.id);

      // (1) dim effect
      const alpha = isDim ? 0.30 : 1.0;

      ctx.save();
      ctx.globalAlpha = alpha;

      // circle
      ctx.beginPath();
      ctx.arc(m.x, m.y, rBase, 0, Math.PI*2);

      // fill
      ctx.fillStyle = "rgba(124,196,255,.18)";
      ctx.fill();

      // ring
      ctx.lineWidth = ring;
      ctx.strokeStyle = "rgba(124,196,255,.95)";
      ctx.stroke();

      // number
      ctx.font = "800 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(231,238,248,.98)";
      ctx.fillText(String(idx), m.x, m.y+0.5);

      ctx.restore();
    }

    /******************************************************************
     * Overlay: ë§ˆì»¤ í…ìŠ¤íŠ¸ + (2) ë©”ëª¨ì¥ íˆ´íŒ
     ******************************************************************/
    function layoutOverlay(){
      overlay.innerHTML = "";
      if (!currentPage) return;

      const markers = currentPage.markers || [];
      for (let i=0; i<markers.length; i++){
        const m = markers[i];

        const p = worldToScreen(m.x, m.y);
        const label = document.createElement("div");
        label.className = "markerLabel";
        label.dataset.mid = m.id;
        label.style.left = p.x + "px";
        label.style.top  = p.y + "px";
        label.textContent = m.label || `ë§ˆì»¤ ${i+1}`;

        const tip = document.createElement("div");
        tip.className = "memoTip";
        tip.innerHTML = `
          <div class="memoTitle">ë©”ëª¨</div>
          <p class="memoText">${escapeHtml(m.memo || "(ë©”ëª¨ ì—†ìŒ)")}</p>
          <div class="memoMeta">
            <span class="pill">#${i+1}</span>
            ${m.linkUrl ? `<span class="pill">ğŸ”— <a class="a" href="${escapeAttr(m.linkUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(m.linkTitle || "ë§í¬ ì—´ê¸°")}</a></span>` : `<span class="pill">ğŸ”— ë§í¬ ì—†ìŒ</span>`}
          </div>
        `;
        label.appendChild(tip);

        // (2) í…ìŠ¤íŠ¸ hover ì‹œ íˆ´íŒ í‘œì‹œ
        label.addEventListener("mouseenter", () => {
          if (pinnedLabelId && pinnedLabelId !== m.id) return;
          tip.classList.add("show");
        });
        label.addEventListener("mouseleave", () => {
          if (pinnedLabelId === m.id) return; // ê³ ì •ì´ë©´ ìœ ì§€
          tip.classList.remove("show");
        });

        // í…ìŠ¤íŠ¸ í´ë¦­ ì‹œ íˆ´íŒ ê³ ì •/í•´ì œ
        label.addEventListener("click", (e) => {
          e.stopPropagation();
          if (pinnedLabelId === m.id){
            pinnedLabelId = null;
            tip.classList.remove("show");
          } else {
            pinnedLabelId = m.id;
            tip.classList.add("show");
          }
        });

        overlay.appendChild(label);
      }
    }

    // overlay ì¢Œí‘œ ê°±ì‹ (ì¤Œ/ì´ë™ í›„)
    function updateOverlayPositions(){
      if (!currentPage) return;
      const labels = overlay.querySelectorAll(".markerLabel");
      const markersById = new Map((currentPage.markers||[]).map(m => [m.id, m]));

      labels.forEach(el=>{
        const m = markersById.get(el.dataset.mid);
        if (!m) return;
        const p = worldToScreen(m.x, m.y);
        el.style.left = p.x + "px";
        el.style.top  = p.y + "px";
      });
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }
    function escapeAttr(s){
      return String(s).replaceAll('"',"&quot;");
    }

    /******************************************************************
     * Interaction
     * - (ì¢Œí´ë¦­ ë“œë˜ê·¸ íŒ¨ë‹ ê°€ëŠ¥) (ì´ì „ ë¬¸ì œ í•´ê²°)
     * - wheel ì¤Œ
     * - pinch ì¤Œ(ê°„ë‹¨)
     * - marker icon click -> (1) dim toggle
     ******************************************************************/
    function getStagePoint(e){
      const r = stage.getBoundingClientRect();
      const x = (e.clientX - r.left);
      const y = (e.clientY - r.top);
      return { x, y };
    }

    function pickMarkerAt(sx, sy){
      if (!currentPage) return null;
      const w = screenToWorld(sx, sy);
      const markers = currentPage.markers || [];
      const hitR = 22; // world units
      for (let i=markers.length-1; i>=0; i--){
        const m = markers[i];
        const dx = w.x - m.x, dy = w.y - m.y;
        if (dx*dx + dy*dy <= hitR*hitR) return m;
      }
      return null;
    }

    stage.addEventListener("pointerdown", (e)=>{
      stage.setPointerCapture(e.pointerId);

      // í…ìŠ¤íŠ¸ íˆ´íŒ ê³ ì • í•´ì œëŠ” ë¹ˆ ê³³ í´ë¦­ìœ¼ë¡œ
      if (e.target === stage || e.target === canvas || e.target === overlay){
        // marker icon click?
        const pt = getStagePoint(e);
        const m = pickMarkerAt(pt.x, pt.y);
        if (m){
          // (1) toggle dim ONLY this marker
          if (dimmed.has(m.id)) dimmed.delete(m.id);
          else dimmed.add(m.id);
          draw();
          // overlayëŠ” í…ìŠ¤íŠ¸ë§Œì´ë¯€ë¡œ ìœ„ì¹˜ë§Œ ê°±ì‹ 
          updateOverlayPositions();
          return; // ë§ˆì»¤ í´ë¦­ì´ë©´ ë“œë˜ê·¸ ì‹œì‘ ì•ˆ í•¨
        } else {
          // ë¹ˆ ê³³ í´ë¦­ì´ë©´ pinned í•´ì œ
          if (pinnedLabelId){
            const pinnedEl = overlay.querySelector(`.markerLabel[data-mid="${CSS.escape(pinnedLabelId)}"] .memoTip`);
            if (pinnedEl) pinnedEl.classList.remove("show");
            pinnedLabelId = null;
          }
        }
      }

      // ë“œë˜ê·¸ ì‹œì‘ (ì¢Œí´ë¦­ í¬í•¨)
      dragging = true;
      dragStart = {
        x: e.clientX,
        y: e.clientY,
        tx: view.tx,
        ty: view.ty
      };
    });

    stage.addEventListener("pointermove", (e)=>{
      if (!dragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      view.tx = dragStart.tx + dx;
      view.ty = dragStart.ty + dy;
      draw();
      updateOverlayPositions();
    });

    stage.addEventListener("pointerup", (e)=>{
      dragging = false;
      try { stage.releasePointerCapture(e.pointerId); } catch {}
    });
    stage.addEventListener("pointercancel", ()=>{
      dragging = false;
    });

    // wheel zoom
    stage.addEventListener("wheel", (e)=>{
      e.preventDefault();
      const pt = getStagePoint(e);
      const delta = e.deltaY;
      const factor = delta > 0 ? 0.92 : 1.08;
      zoomAt(factor, pt.x, pt.y);
    }, { passive:false });

    // pinch zoom (ê°„ë‹¨)
    const touches = new Map();
    stage.addEventListener("pointerdown", (e)=>{
      if (e.pointerType === "touch"){
        touches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      }
    });
    stage.addEventListener("pointermove", (e)=>{
      if (e.pointerType !== "touch") return;
      if (!touches.has(e.pointerId)) return;
      touches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (touches.size === 2){
        const pts = Array.from(touches.values());
        const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
        // store on element
        if (!stage._pinchLast) stage._pinchLast = d;
        const diff = d / stage._pinchLast;
        stage._pinchLast = d;

        const r = stage.getBoundingClientRect();
        const cx = ((pts[0].x+pts[1].x)/2) - r.left;
        const cy = ((pts[0].y+pts[1].y)/2) - r.top;
        zoomAt(clamp(diff, 0.92, 1.08), cx, cy);
      }
    });
    stage.addEventListener("pointerup", (e)=>{
      if (e.pointerType === "touch"){
        touches.delete(e.pointerId);
        if (touches.size < 2) stage._pinchLast = null;
      }
    });
    stage.addEventListener("pointercancel", (e)=>{
      if (e.pointerType === "touch"){
        touches.delete(e.pointerId);
        if (touches.size < 2) stage._pinchLast = null;
      }
    });

    /******************************************************************
     * UI actions
     ******************************************************************/
    btnResetOpacity.addEventListener("click", ()=>{
      dimmed.clear();
      draw();
      updateOverlayPositions();
    });

    btnFit.addEventListener("click", fitToScreen);
    btnZoomIn.addEventListener("click", ()=>{
      const r = stage.getBoundingClientRect();
      zoomAt(1.12, r.width/2, r.height/2);
    });
    btnZoomOut.addEventListener("click", ()=>{
      const r = stage.getBoundingClientRect();
      zoomAt(0.89, r.width/2, r.height/2);
    });

    btnReload.addEventListener("click", async ()=>{
      await loadState({ bypassCache:true });
    });

    btnClearLocal.addEventListener("click", ()=>{
      localStorage.removeItem(LS_KEY);
      alert("ë¡œì»¬ ìºì‹œë¥¼ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.\nìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ 'state.json ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°'ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    });

    pageSelect.addEventListener("change", ()=>{
      const id = pageSelect.value;
      selectPageById(id);
    });

    // ë¹ˆ ê³³ í´ë¦­í•˜ë©´ pinned í•´ì œ + íˆ´íŒ ìˆ¨ê¹€
    stage.addEventListener("click", (e)=>{
      if (e.target.closest && e.target.closest(".markerLabel")) return;
      if (pinnedLabelId){
        const pinnedEl = overlay.querySelector(`.markerLabel[data-mid="${CSS.escape(pinnedLabelId)}"] .memoTip`);
        if (pinnedEl) pinnedEl.classList.remove("show");
        pinnedLabelId = null;
      }
    });

    /******************************************************************
     * State load (REMOTE_STATE_URL) + êµ¬ì¡° ìœ ì—° ì²˜ë¦¬
     ******************************************************************/
    async function loadState({ bypassCache=false } = {}){
      // cache
      if (!bypassCache){
        const cached = safeJsonParse(localStorage.getItem(LS_KEY));
        if (cached){
          state = normalizeState(cached) || FALLBACK_STATE;
          applyState();
          // background refresh try
          tryFetchAndUpdate(false);
          return;
        }
      }
      await tryFetchAndUpdate(true);
    }

    async function tryFetchAndUpdate(showAlertOnFail){
      try{
        const res = await fetch(REMOTE_STATE_URL.href, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();

        const normalized = normalizeState(json);
        if (!normalized) throw new Error("state.json êµ¬ì¡°ë¥¼ ì¸ì‹í•  ìˆ˜ ì—†ìŒ");

        state = normalized;
        localStorage.setItem(LS_KEY, JSON.stringify(state));
        applyState();
      }catch(err){
        console.warn("state.json load failed:", err);
        state = FALLBACK_STATE;
        applyState();
        if (showAlertOnFail){
          // ë„ˆë¬´ ì‹œë„ëŸ½ì§€ ì•Šê²Œ 1íšŒë§Œ
          console.log("fallback state used");
        }
      }
    }

    function safeJsonParse(s){
      try{ return s ? JSON.parse(s) : null; }catch{ return null; }
    }

    /**
     * normalizeState:
     * - ê°€ëŠ¥í•œ í•œ ë‹¤ì–‘í•œ êµ¬ì¡°ë¥¼ ë°›ì•„ì„œ {title, pages:[{id,name,imageUrl,markers:[]}] } í˜•íƒœë¡œ ë§ì¶¤
     * - ì¸ì‹ ì‹¤íŒ¨ ì‹œ null
     */
    function normalizeState(input){
      if (!input || typeof input !== "object") return null;

      // already normalized?
      if (Array.isArray(input.pages)){
        return {
          version: input.version || "7.0.0",
          title: input.title || "Interactive Map",
          pages: input.pages.map(p => ({
            id: String(p.id ?? p.pageId ?? crypto.randomUUID()),
            name: String(p.name ?? p.title ?? "í˜ì´ì§€"),
            imageUrl: p.imageUrl || p.image || p.mapImage || "",
            markers: Array.isArray(p.markers) ? p.markers.map(m => ({
              id: String(m.id ?? m.mid ?? crypto.randomUUID()),
              x: Number(m.x ?? m.wx ?? 0),
              y: Number(m.y ?? m.wy ?? 0),
              label: m.label ?? m.text ?? m.title ?? "",
              memo: m.memo ?? m.note ?? m.desc ?? "",
              linkTitle: m.linkTitle ?? m.videoTitle ?? m.urlTitle ?? "",
              linkUrl: m.linkUrl ?? m.url ?? m.youtube ?? ""
            })) : []
          }))
        };
      }

      // maybe input has "maps" or "data.pages" etc.
      const candidatePages =
        (Array.isArray(input.maps) && input.maps) ||
        (input.data && Array.isArray(input.data.pages) && input.data.pages) ||
        (input.data && Array.isArray(input.data.maps) && input.data.maps);

      if (Array.isArray(candidatePages)){
        return {
          version: input.version || "7.0.0",
          title: input.title || input.name || "Interactive Map",
          pages: candidatePages.map(p => ({
            id: String(p.id ?? p.pageId ?? p.key ?? crypto.randomUUID()),
            name: String(p.name ?? p.title ?? p.label ?? "í˜ì´ì§€"),
            imageUrl: p.imageUrl || p.image || p.src || "",
            markers: Array.isArray(p.markers) ? p.markers.map(m => ({
              id: String(m.id ?? m.mid ?? crypto.randomUUID()),
              x: Number(m.x ?? m.wx ?? 0),
              y: Number(m.y ?? m.wy ?? 0),
              label: m.label ?? m.text ?? m.title ?? "",
              memo: m.memo ?? m.note ?? m.desc ?? "",
              linkTitle: m.linkTitle ?? m.videoTitle ?? m.urlTitle ?? "",
              linkUrl: m.linkUrl ?? m.url ?? m.youtube ?? ""
            })) : []
          }))
        };
      }

      return null;
    }

    function applyState(){
      titleText.textContent = state.title || "Interactive Map";

      // pages select
      pageSelect.innerHTML = "";
      const pages = state.pages || [];
      for (const p of pages){
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name || p.id;
        pageSelect.appendChild(opt);
      }

      if (pages.length){
        selectPageById(pages[0].id);
      } else {
        currentPage = null;
        draw();
        overlay.innerHTML = "";
      }
    }

    function selectPageById(id){
      const pages = state.pages || [];
      const p = pages.find(x => x.id === id) || pages[0];
      currentPage = p;

      // reset pin (í˜ì´ì§€ ë°”ë€Œë©´ íˆ´íŒ ê³ ì • í•´ì œ)
      pinnedLabelId = null;

      // ì´ë¯¸ì§€ ë¡œë“œ
      const url = (p && p.imageUrl) ? p.imageUrl : "";
      if (url){
        img.onload = () => {
          // ì´ë¯¸ì§€ê°€ ë°”ë€Œë©´ ì „ì²´ í™”ë©´ ë§ì¶¤
          fitToScreen();
        };
        img.onerror = () => {
          // ì´ë¯¸ì§€ ì—†ë”ë¼ë„ ë§ˆì»¤ëŠ” ë‚˜ì˜¤ê²Œ
          img = new Image();
          draw();
          fitToScreen();
        };
        img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
      } else {
        img = new Image();
        fitToScreen();
      }

      // dimmedëŠ” í˜ì´ì§€ ë„˜ì–´ê°€ë©´ ìœ ì§€(ê¸°ì¡´ ë™ì‘ì´ ë­”ì§€ ëª°ë¼ì„œ)
      // í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ dimmed.clear() í•˜ë©´ ë¨.
      draw();
      layoutOverlay();
      updateOverlayPositions();
      pageSelect.value = p.id;
    }

    /******************************************************************
     * init
     ******************************************************************/
    resize();
    loadState();

  </script>
</body>
</html>
